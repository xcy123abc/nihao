mybatis：
	
	入门案例：（代码test01）
		总结 使用mybatis框架不用写dao实现类 其中配置映射文件的那部分就相当于在实现方法了
			 测试的时候 用代理模式 用sqlsession。getmapper（接口字节码）获取接口的对象  就相当
			 于实例类的对象了 然后就可以执行方法 下面是入门案例的编写过程
			 
	入门案例之――――mybatis的环境搭建：
		1.创建maven工程 导入jar包（mybatis，mysql-connector-java，junit，log4j）
		
		2.创建实体类（实现接口 Serializable ） 和dao接口（写所需方法）
		
		3.创建mybaris的主配置文件（里面会映射接口的配置文件）
			sqlmapConfig.xml
				a.约束
				<configuration>
				b.配置环境
					环境s下配置mysql环境（大环境属性为default，值为mysql  环境属性id的值为mysql）
					环境里配置事务管理 环境内部配置一个type=“JDBC"（内部指位置与标签同一等级）
					配置数据源  内部 type是”POOLED“  其中用property配置四个参数 驱动 数据库 用户名和密码
				c.配置映射<mappers><mapper resource="dao/IUserDao.xml"/>
				eg：
					<?xml version="1.0" encoding="UTF-8"?>
					<!DOCTYPE configuration
							PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
							"http://mybatis.org/dtd/mybatis-3-config.dtd">

					<!-- 主配置 -->
					<configuration>
						<environments default="mysql">
							<environment id="mysql">
								<transactionManager type="JDBC"></transactionManager>
								<dataSource type="POOLED">
									<!-- -->
									<property name="driver" value="com.mysql.jdbc.Driver"/>
									<property name="url" value="jdbc:mysql://localhost:3366/xcy"/>
									<property name="username" value="root"/>
									<property name="password" value="124546"/>
								</dataSource>
							</environment>
						</environments>
						<mappers>
							<mapper resource="dao/IUserDao.xml"/>
						</mappers>
					</configuration>
					
		4.创建接口映射配置文件（一个 接口对应一个配置文件）
			IUserDao.xml（IUserMapper.xml）
				a. 约束
				b. 标签mapper 内部需要namespace 值为接口位置的全限定类名
				c. 在mapper标签里配置方法
					相应标签（select）内部再写id  和resulttype 标签中写sql语句
					eg：<select id="findAll" resultType="domain.User">select * from user</select>

				eg：
					<?xml version="1.0" encoding="UTF-8"?>
					<!DOCTYPE mapper
							PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
							"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
					<mapper namespace="dao.IUserDao">
						<select id="findAll" resultType="domain.User">
						  select * from user
						</select>
						<insert id="saveUser" parameterType="domain.User">
							insert into user(username,address,sex,birthday)value (#{username},
							 #{address},#{sex},#{birthday})
						</insert>
					</mapper>
					
		5.还需要一个log4j。properties配置文件
			eg：# Set root category priority to INFO and its only appender to CONSOLE.
				#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
				log4j.rootCategory=debug, CONSOLE, LOGFILE

				# Set the enterprise logger category to FATAL and its only appender to CONSOLE.
				log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE

				# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
				log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
				log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
				log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n

				# LOGFILE is set to be a File appender using a PatternLayout.
				log4j.appender.LOGFILE=org.apache.log4j.FileAppender
				log4j.appender.LOGFILE.File=d:\axis.log
				log4j.appender.LOGFILE.Append=true
				log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
				log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n

		注意：  1.包和目录的创建不一样
				2.保持dao接口和dao配置文件的文件目录结构相同
				3.映射配置文件的mapper标签的namespace属性的取值必须是接口的全限定类名（src/main/java往后开始写起）
				4.映射配置文件的操作配置（select），id属性取值必须是dao接口的方法名
			满足上面条件  开发中就无需再写dao实现类
	入门案例：	
		1.读取配置文件 生成字节输入流   
			in = Resources.getResourceAsStream("SqlMapConfig.xml");
		2.创建SqlSessionFactory工厂（目的是获取sqlsession）
			SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
		3.获取sqlsession（）
			sqlSession = factory.openSession();
		4.创建dao接口的代理对象
			userDao = sqlSession.getMapper(IUserDao.class);
		5.执行方法
			 List<User> users = userDao.findAll();
		6.释放资源
			 //提交事务
			sqlSession.commit();
			//6.释放资源
			sqlSession.close();
			in.close();
		注意：记得在映射文件中配置结构封装到哪个实体类中（全限定类名）
		
	上面是xml配置的
	下面是注解搭建（在xml中改编）（代码test02）
		1.需要主配置文件
		2.接口映射配置文件删除  在接口的方法上使用@Select注解 并且只当sql语句
		3.主配置文件的mapper部分  把resource属性改为class属性 值是dao接口的全限定类名
		4.配置pom
	
	
	mybatis第二部分 
		1.增删改查的语句
		2.<delete>或者其他标签的内部属性 比如 resultType有时候需要改成parametertype （两者没有关系hhh）   
			也可以理解为需要带参数的方法需要怎么配置  配置parametertype  然后用#{}来接受方法的参数
		3.模糊查询建议在测试时使用占位符 因为这种有预编译处理（#{}与￥{}的区别，建议使用#{}）
		4.keypropres对应实体类的属性
			keyColumn对应表的属性
			order属性
		5.OGNL表达式
			0GNL表达式:
				0bject Graphic Navigation Language
				对象图	导航语言
				它是通过对象的取值方法来获取数据。在写法上把get给省略了。
				比如:我们获取用户的名称
				类中的写法: :user. getUsername () ; 
				OGNL表达式写法: yser. username
				mybatis中为什么能直接写username,而不用user.呢:
				因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名
				
		6.实体类的属性和表的属性不一样 解决：
			1.改ognl表达式和keyproperid（开发效率快）注意第二种的映射，其中resultType要改为resultmapper
			2.在映射的配置里sql语句的属性取别名（执行效率高）
		7.断点调试 源码追踪：
			右键接口名，选择diagran ，第一个选项，出来一个接口的正方形，右键，选showInter。。。
			然后选实现类   
		8.	（编写实现类的）
			PreparedStatement对象   它的执行方法

			execute :它能执行CRUD中的任意一种语句。 它的返回值是-个boolean类型 ,表示是否有结果集。有结果集是true 
					 没有结果集是false.

			executeUpdate :它只能执行CUD语句,查询语句无法执行。他的返回值是影响数据库记录的行数

			executeQuery :它只能执行SELECT语句,无法执行增删改。执行结果封装的结果;集ResultSet对象
			
		9.properties属性	
			1.支持在property 的value属性中引用别的property的name
				eg：配置数据源的时候 可以先配置一个properties 里面是四个property配置的数据源数据 驱动 数据库等等
					然后在数据源配置时用value=”${driver}引用
			2.引用配置文件
				eg：《properties resource=“xxx。properties”》《/properties》（配置文件在类路径下）===========？？类路径
					同样在property的value=“${driver}”  引用
		10.url与uri		
				
		11 标签《typeAliases》  给类起别名，只能配置domain类中  type全限定类名  和  alisa别名
		
		12 package   在主配置文件的mapper里 用该标签的name属性 指定 dao接口所在的包名 就不需要resource或者class		
		
	第三部分：连接池 事务 动态sql语句   多表操作 
	
		概述：
			mybatis中的连接池和事物     原理了解  应用会用
			动态sql语句					会用
			多表操作					掌握会用
			
		连接池：实际开发中都会使用连接池 因为可以减少获取连接所需要的时间
				连接池就是一个存储连接的容器（连接池的底层是ArrayList） 
				其实就是一个集合对象 该集合必须是线程安全的 （不能两个线程同时拿到一个连接）
				改集合还必须实现队列的特型 先进先出
			分类：POOLED     pooled  没有用c3p0和dbcp，mybatis自己实现的一套连接池的思想
							 也是用jdbc规范中的javax。sql。datasource接口实现的方式
				  UNPOOLED
				  JNDI
			这里有一段话没有记录======================主号搜连接池没有记录========================？？
			
		事务：事务可以用openSession（true）  开启
		
		动态sql语句：
			《id》
				and
				
			范围查询配置：
				SQL 语句： select * from user where id in (?)
				<forea >  用于遍历集合 
					属性；
						collection:  遍历的集合元素 编写时不能使用#{}
						open：  代表语句的开始部分
						close： 代表结束的部分
						iten：  代表遍历集合的每个元素  生成的变量名
						sperator： 代表分隔符
				<>
			eg：  
				<select id="findUserInIds" resultMap="userMap" parameterType-"queryvo" >
					select * from user
				< where>
					<if test="ids ！= null and ids.size( )>0">
						<foreach collection="ids" open="and id in (" close=")" item "uid" separator-" , ">
							#(uid)
						</foreach>

		多表操作：一对多
				  多对一
				  一对一
				  多对多

		
		mybatis缓存
			延迟加载
			立即加载
			一对多 多对多   一般是延迟加载
			多对一 一对一   一般是立即加载
		eg：
			一对多为例  实现延迟加载
			1.新建工程 2. 复制文件  pom 
			2.配置延迟加载
			3.再配置 （mybatis文档里，找xml配置，setting配置     lazyloadongenaoble
			4.主配置里（配置里加settings配置 需要两个）

		缓存：存在于内存之中的临时数据
		为什么使用缓存：减少和数据库交互的次数 提高执行效率

		一级缓存和二级缓存：
		
			一级：sqlsession对象的缓存（自动开启）
				执行查询时 查询结果会存入到sqlsession为我们提供的区域中
				该区域的结构是一个Map  当我们再次查询时 mybatis会先查询缓存区域
				sqlsession对象消失时 mybatis的一级缓存也就消失了
				调用updata方式，缓存会被清空（sqlsession。clearCache（）也可以清空缓存）
				
				
			二级：
				定义：
					指mybatis中SqlSessionFactory对象的缓存  同一个对象创建出来的sqlsession共享缓存
				开启：
					1.在主配置文件中开启支持  <settings>
												<setting name="cacheEnable" value="true"/>
					2.在接口配置文件中 mapper标签里加《cache/》
					3.select标签中开启	select的内部属性 useCache=“ture”
				存放的是数据  而不是对象
			
			
	Mybatis的注解开发：
		注解开发：
			1.新建maven工程 配置pom 打包方式选jar
			2.pom导入四个依赖（mybatis开发就够了）
			3.新建实体类（实现序列化接口）（getter和同string）
			4.新建接口

			5.写主配置文件（config约束）其他手写（在resources目录下）写一个config，里面
				1.引入jdbc配置文件（用《properties resources=“文件名”》）
			  
					配置别名（）
					《typeAliases》
					《package  name=“实体类所在的包名”》 
			  
				2.用《environments》配置环境
					第一个有default的属性，值为mysql
					然后是《environment id=“mysql”》
							《transactionManage type=“JDBC”》《/》
							《dataSource type=“POOLED”》
								datasource里要用property配置四个信息
								这里是使用第一步引入的配置文件
								eg：《property name=“driver” value=“${jdbc.driver}”》《/preproperty》
				
				3.映射dao接口的所在位置（用mapper）
					《mapper》
						《package naem=“接口所在的包的位置”》《/package》
			 
				
			 * 配置文件都在rsource目录下（除非是接口的映射，才需要和接口的结构相同）    

			6. 写注解（注解有四种，selete，insert，update，delete）
			   接口方法上@Selete（“sql语句”）

			
			7.测试和使用注意事项
				创建测试类
					1.获取字节流（用resources（ibatis的包）的getResourcesAsString的方式，传入主配置文件的名字获取流）
					2.根据流构建sqlsessionfactory（使用sqlsessionfactorybuilder。build（in）获取）
					3.生成一个sqlsession
					4.使用sqlsession获取代理对象
						其中，获取代理对象，使用session的getmapper方法，参数传递对应接口的类字节码文件
					5.执行dao
					6.释放资源
				注意：1.使用注解开发的时候，就不能在同一个接口中使用配置开发，会报错
					   不管主配置文件有没有使用mapper映射配置文件
					  2.注解开发的获取对象也是要使用代理模式
		常用注解：
			@select
			@Results(
				id="userMap"  value={
				@Result(id=tyre , colum="",property=""),
				@Result(colum="",property=""),

				}
			)
			@ResultMap("userMap")
			@CacheNamespace(blocking = true )
			@Result(colum="",property="" ,one=@one(select = "com.itcast.dao.IUserDao.findById",fetchType.EAGER))
			
		
	
Spring：
	耦合：程序见的依赖关系（类，方法之间）
	
	获取流的时候，需要一个文件的路径，这是相对和绝对路径都不合适
	需要用加载器的getResourceAsStean的方法获取指定文件的流（参数是文件的名字）
	
	加载properties文件的方法，获取一个properties对象，调用load方法，参数是指向
	目标文件的流（类加载器获取流）
	
	反射Class。forName参数要是全限定类名。方法的返回值是该类的类***
	然后调用invo方法获取对象
	
	业务层和持久层，很少包含可以修改类成员，所以单例对我们来说效果更好
	
	控制反转：把创建对象的权力交给框架或者工厂，它包括依赖注入（DI）和依赖查找
	
	spring文档，其中的libs，有63个，实际21个，三个一组们没有任何后缀，是编译用的，
	（导包），，看文档，用doc后缀的，，看源码，用sources
	
**搭建spring基于xml的ioc
		1.创建maven工程
		2.pom配置打包方式（jar）
		3.pom中配置spring IoC的依赖jar包（spring-context） sql驱动
		4.创建bean.xml
			a.导入文件约束（网页搜xmls）
			b.对象交给spring管理（bean配置）
				id  对象的别名
				class 全限定类名
		5. 测试使用：（获取容器，更具id获取对象）
			a.获取核心容器对象（参数是bean.xml）
				ac = new ClassPathXmlApplicationContext(bean,xml);
			b. ac.getBean(id,类字节码文件);  //获取对象
			
	补充：ApplicationContext的三个常用实现类：
     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件
								要求配置文件必须在类路径下。不在的话，加载不了。(更常用)
								
     *      FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件
									(必须有访问权限）
     *
     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的
		
		核心容器的两个接口引发出的问题：
     *  ApplicationContext:     单例对象适用              采用此接口
     *      它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。
			也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。
     *
     *  BeanFactory:            多例对象使用
     *      它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。
			也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。
			
			
spring对对象的管理：
		1.创建bean的三种方式
			a.  bean  使用bean标签，配以id和class属性之后，且没有其他标签时
					  采用的就是默认构造函数构造对象，此时如果类没有默认构造函数 则无法创建
					  
			b. bean 其中配置 id factory-bean  factory-method 标签 
			   使用类中的方法创建对象，存入spring容器
			   
			c. 使用工厂（类）中的静态方法创建对象
				bean 其中配置class factory-method 标签
			
		2.bean对象的作用范围
			bean标签的scope属性：
				作用：指定bean的作用范围
				取值：
					singleton：单例的（默认值）
					prototype：多例的
					request：作用于web应用的请求范围
					session：作用于web应用的会话范围
					global-session：作用于集群环境的会话范围（全局会话范围）
									当不是集群环境时 它就是session
		3.bean对象的生命周期
				单例对象的生命周期：
					出生：容器被创建时对象出生
					或者：容器还在，对象一直活着
					死亡：容器销毁 对象消亡
					总结：单例对象的生命周期 与容器相同
				多例对象的生命周期：
					出生：当我们使用对象时spring框架为我们创建
					活着：对象只要在使用过程中就一直活着
					死亡：当对象长时间不用
	
spring的依赖注入（DI）
	依赖关系的维护 就称为依赖注入
	依赖注入的数据（三类）：
		基本类型和String
		其他bean类型
		复杂类型/集合
	注入方式：三种
		1.使用构造函数提供
			构造函数注入：
				标签：constructor-arg
					标签中的属性：
						type
						index
						name：     指定参数名称
						=============两组
						value：用于提高基本数据类型和String类型
						ref：  用于提供容器之中的bean对象
			优势：获取bean对象时 注入数据是必须操作 否则无法创建对象
			弊端：改变bean对象的实例化方式 使在创建对象时  如果用不到这些数据也必须提供
		* 2.使用set方法提供
			标签：property
			标签属性：
				name：
				value：
				ref：
			优势：创建对象时没有明确的限制 可以直接使用默认构造函数
			弊端：如果某个成员必须有值 则获取对象是有可能set方法没有执行
			eg：<property name="name" value="zhangsan"></property>
			
		* 复杂类型注入
			给list结构的集合注入的标签
				list array set
			给map结构的集合注入的标签
				map props
			结构相同 标签可以互换
			
		3.使用注解提供
			
上面是使用配置bean.xml文件开发
下面是使用注解开发
	下面是使用注释开发的步骤：
		1.准备实体类，接口，配置文件，数据库表格      
		2.使用注解，把类加入容器。     
		3.配置文件,需要约束，在收藏里找，code-》查找   xmls： 找到有context的，复制        
		4.配置创建容器要导入的包（context:component-scan bese-pack=" "> ）    
		
用于创建对象的注解
		Component:
			作用：用于把当前类对象存入spring容器中
			属性：
				value：用于指定这个对象（bean）的id  默认是当前类名，首字母小写
		Controller: 一般用在表现层
		
		Service: 一般用在服务层
		Repository:一般用在持久层
		上面四个注解的后三个的作用和属性与第一个一模一样
		
用于注入数据的注解
		作用类似在xml配置文件中写一个<property>标签
		Autowired：
			作用：自动类型注入，容器有唯一一个类型和变量类型相匹配，则注入成功
			出现位置：变量 方法
			细节：使用注解注入时 set方法就不是必须的了
		Qualifier:
			作用: 	在按照类型注入的基础之上再按照名称注入 在给类成员注入时不能单独使用
					但是在给方法参数注入时可以
			属性：
				value：用于指定注入bean的id
				
		Resource:
			作用：直接按照bean的id注入 它可以独立使用
			属性：
				name：用于指定bean的id
				
		以上三个用来注入其他bena类型的数据   基本数据类型和String类型用Value实现
		集合类型的注入只能通过xml配置实现
		
		Value:
			作用：注入基本数据类型和String类型
			属性：	
				value：用于指定数据的值，也可以使用spring中的sqEL
				sqEL写法： ${表达式}
	
用于改变作用范围的注解
		Scope
			作用：指定bean的作用范围
			属性：	
				value：指定范围的取值  （singleton  prototype）

和生命周期相关 （了解）
	PreDestory：用于指定销毁方法
	PostConstruct：用于指定销毁方法
	
使用新注解，完全代替xml配置文件
	1.写一个类代替xml配置文件
		@Configuration  作用：指定当前类是一个配置类
	
		@ComponentScan  作用：指定创建容器时要扫描的包
						属性：指定包名
						
	2.创建一个方法，返回值是一个对象
		使用注解 把这个对象放到容器
		@bean
			作用：用于把当前方法返回值存入spring容器中
			属性：
				name：用于指定bean的id  默认是当前方法的名称
			细节：使用注解配置方法时  如果方法有参数 框架会查找容器中有无可用对象
					查找方式和Autowired注解的作用是一样的
			
	3.更换测试列类中获取容器的方法
		用 AnnotationConfigApplicationContext( xxx.class);获取容器
		测试的时候，需要换一个类来获取容器。参数是代替配置文件的类的字节码
		测试的时候测试查询和增加就够了
		
		注意：配置后，虽然xml文件已经没有了，并且可以运行，但是qrunner不是单例的
				和xml配置的效果不一样  所以qrunner需要用注解实现多例
			@Scope（"prototype"）
			
	优化使用全注解开发
		1.新注解import：使得配置有主次之分，更合理
			@Import（jdbcConfig.class）
			
		2.把jdbc的配置提取成properties文件
			a.@PropertySource（“classpath；jdbcConfig。properties”）
				使用注解，指定配置文件的位置
				属性：
					value：指定文件的名称和路径
						关键字：classpath，表示类路径下
			b.配置类（主配置）中     类增加属性，保存连接数据库需要的数据     
			c.用注解给属性注入值，实现初始化
				@Value（“${jdbc.username}”）
			
		
		3.优化测试类：spring整合junit的配置
			步骤：
				1. 导入坐标 spring整合junit的jar
				2.@Runwith（SpringJUnit4ClassRunner.class）  
					替换原来的main方法
					
				3.@ContextConfigration(classes=SpringConfigration.class)
					告知容器ioc创建是基于注解还是基于配置，并说明位置
					location：指定xml文件的位置，加上classpath关键字 表示在类路径下
					classes：指定注解类所在的位置
					
					注意：
						使用注解配置的测试类 @ContextConfigration(classes=SpringConfigration.class)
						使用配置文件的测试类 @ContextConfigration（location：指定xml文件的位置，加上classpath关键字
																	表示在类路径下）
			使用spring 5.x版本的时候  要求junit必须是4.12及以上
		
		
		
@Qualifier的另一种用法
			在形式参数前使用@Qualifier（“beanId"）,给参数注入值
			
			
spring的aop
	引出案例：转账案例的问题，多步操作使用的是不同的connection连接对象
				会出现不一致问题
				解决 1. 把connection对象与线程绑定 （一个线程只能使用一个连接对象） 
					2. 创建一个事务控制的类，里面提供一些方法，包括事务处理完
						线程和连接对象的解绑	
					3.账户实例类改造方法，使其支持事务
					
				事务控制从持久层变成业务层  测试可以通过
				
	动态代理知识加强：
		 动态代理：
         *  特点：字节码随用随创建，随用随加载
         *  作用：不修改源码的基础上对方法增强
         *  分类：
         *      基于接口的动态代理
         *      基于子类的动态代理
         *  基于接口的动态代理：
         *      涉及的类：Proxy
         *      提供者：JDK官方
         *  如何创建代理对象：
         *      使用Proxy类中的newProxyInstance方法
         *  创建代理对象的要求：
         *      被代理类最少实现一个接口，如果没有则不能使用
         *  newProxyInstance方法的参数：
         *      ClassLoader：类加载器
         *          它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。
         *      Class[]：字节码数组
         *          它是用于让代理对象和被代理对象有相同方法。固定写法。
         *      InvocationHandler：用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
		 eg：IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),
                producer.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 作用：执行被代理对象的任何接口方法都会经过该方法
                     * 方法参数的含义
                     * @param proxy   代理对象的引用
                     * @param method  当前执行的方法
                     * @param args    当前执行方法所需的参数
                     * @return        和被代理对象方法有相同的返回值
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //提供增强的代码
                        Object returnValue = null;

                        //1.获取方法执行的参数
                        Float money = (Float)args[0];
                        //2.判断当前方法是不是销售
                        if("saleProduct".equals(method.getName())) {
                            returnValue = method.invoke(producer, money*0.8f);
                        }
                        return returnValue;
                    }
                });
        proxyProducer.saleProduct(10000f);
		基于接口：弊端。如果类没有实现接口，就会出现代理异常		
		基于子类的动态代理
				需要添加依赖  cglib	 
		基于子类的动态代理：
         *      涉及的类：Enhancer
         *      提供者：第三方cglib库
         *  如何创建代理对象：
         *      使用Enhancer类中的create方法
         *  创建代理对象的要求：
         *      被代理类不能是最终类
         *  create方法的参数：
         *      Class：字节码
         *          它是用于指定被代理对象的字节码。
         *
         *      Callback：用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
         *          我们一般写的都是该接口的子接口实现类：MethodInterceptor
         */
        Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() {
            /**
             * 执行北地阿里对象的任何方法都会经过该方法
             * @param proxy
             * @param method
             * @param args
             *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的
             * @param methodProxy ：当前执行方法的代理对象
             * @return
             * @throws Throwable
             */
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                //提供增强的代码
                Object returnValue = null;

                //1.获取方法执行的参数
                Float money = (Float)args[0];
                //2.判断当前方法是不是销售
                if("saleProduct".equals(method.getName())) {
                    returnValue = method.invoke(producer, money*0.8f);
                }
                return returnValue;
            }
        });
        cglibProducer.saleProduct(12000f);		
		此时，业务层不需要事务控制相关的属性了	也就是说业务层和事务控制分离了	要测试前还需要补全配置文件
				具体代码笔记有
	spring的aop	：
		面向切面编程：实现方法，使用动态代理   
		优点：增强代码的可重用性  减少重复代码  提高开发效率 维护方便
		spring通过配置实现，也是注解和配置文件方式两种		
		要求被代理类不能是最终类
		接口至少有实现一个  且final修饰
	相关术语	
		连接点 
		切入点
		通知（增强）
		引介
		目标对象（被代理对象）
		织入
		proxy（代理对象）（被代理对象被增强后就变成代理对象）
		切面：切入点和通知（引介）的结合  
				切面可以理解为编写怎么增强对象方法的那个方法的过程
				
		环绕通知与切入点方法调用（截图）==================================？
		
	**基于配置实现的aop	
		1.配置pom，配置打包方式   配置依赖2个
		2.编写业务层接口
		3.写实现类
		3.准备一个具有公共代码的类（案例用于记录日志）
		4.配置bean。xml     先从ioc开始配置  然后配置aop （下面）
		5.配置文件写完，就可以写测试类来测试
	配置文件：
		<?xml version="1.0" encoding="UTF-8"?>
		<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 配置srping的Ioc,把service对象配置进来-->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>

    <!--spring中基于XML的AOP配置步骤
        1、把通知Bean也交给spring来管理
        2、使用aop:config标签表明开始AOP的配置
        3、使用aop:aspect标签表明配置切面
                id属性：是给切面提供一个唯一标识
                ref属性：是指定通知类bean的Id。
        4、在aop:aspect标签的内部使用对应标签来配置通知的类型
               我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知
               aop:before：表示配置前置通知
                    method属性：用于指定Logger类中哪个方法是前置通知
                    pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强

            切入点表达式的写法：
                关键字：execution(表达式)
                表达式：
                    访问修饰符  返回值  包名.包名.包名...类名.方法名(参数列表)
                标准的表达式写法：
                    public void com.itheima.service.impl.AccountServiceImpl.saveAccount()
                访问修饰符可以省略
                    void com.itheima.service.impl.AccountServiceImpl.saveAccount()
                返回值可以使用通配符，表示任意返回值
                    * com.itheima.service.impl.AccountServiceImpl.saveAccount()
                包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.
                    * *.*.*.*.AccountServiceImpl.saveAccount())
                包名可以使用..表示当前包及其子包
                    * *..AccountServiceImpl.saveAccount()
                类名和方法名都可以使用*来实现通配
                    * *..*.*()
                参数列表：
                    可以直接写数据类型：
                        基本类型直接写名称           int
                        引用类型写包名.类名的方式   java.lang.String
                    可以使用通配符表示任意类型，但是必须有参数
                    可以使用..表示有无参数均可，有参数可以是任意类型
                全通配写法：
                    * *..*.*(..)

                实际开发中切入点表达式的通常写法：
                    切到业务层实现类下的所有方法
                        * com.itheima.service.impl.*.*(..)
    -->

    <!-- 配置Logger类 -->
    <bean id="logger" class="com.itheima.utils.Logger"></bean>

    <!--配置AOP-->
    <aop:config>
        <!--配置切面 -->
        <aop:aspect id="logAdvice" ref="logger">
            <!-- 配置通知的类型，并且建立通知方法和切入点方法的关联-->
            <aop:before method="printLog" pointcut="execution(* com.itheima.service.impl.*.*(..))">
			</aop:before>
        </aop:aspect>
    </aop:config>

</beans>
	以上已经是aop基于注解配置的入门
	通知的几种类型：
		<!--配置AOP-->
    <aop:config>
        <!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容
              此标签写在aop:aspect标签内部只能当前切面使用。
              它还可以写在aop:aspect外面，此时就变成了所有切面可用
          -->
        <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"></aop:pointcut>
        <!--配置切面 -->
        <aop:aspect id="logAdvice" ref="logger">
            <!-- 配置前置通知：在切入点方法执行之前执行
            <aop:before method="beforePrintLog" pointcut-ref="pt1" ></aop:before>-->

            <!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个
            <aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"></aop:after-returning>-->

            <!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个
            <aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"></aop:after-throwing>-->

            <!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行
            <aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>-->

            <!-- 配置环绕通知 详细的注释请看Logger类中-->
            <aop:around method="aroundPringLog" pointcut-ref="pt1"></aop:around>
        </aop:aspect>
    </aop:config>
	
	环绕通知：
	/**
     * 环绕通知
     * 问题：
     *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。
     * 分析：
     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。
     * 解决：
     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。
     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。
     *
     * spring中的环绕通知：
     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。
     */
    @Around("pt1()")
    public Object aroundPringLog(ProceedingJoinPoint pjp){
        Object rtValue = null;
        try{
            Object[] args = pjp.getArgs();//得到方法执行所需的参数

            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。前置");

            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）

            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。后置");

            return rtValue;
        }catch (Throwable t){
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。异常");
            throw new RuntimeException(t);
        }finally {
            System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。最终");
        }
    }
}
	有一个疑问切入点方法怎么执行=============================================？？
	基于注解的aop实现已经结束

	下面是基于注解的aop实现
		新建工程 配置pom  拷贝代码
		使用注解  1.扫描的包  2.注释切面   3.通知（建议使用环绕通知）
		
		 @Pointcut("execution(* com.itheima.service.impl.*.*(..))")
		 private void pt1(){}

		
		
		<!-- 配置spring创建容器时要扫描的包-->
		<context:component-scan base-package="com.itheima"></context:component-scan>

		<!-- 配置spring开启注解AOP的支持 -->
		<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
	
	
	
	**实体类的创建步骤；一般要实现Seri接口，属性，get和set toString
	
	jdbctemple
		基本用法：（需要配置jdbctemplate  里面需要注入数据源 所以还需要配置数据源）
			1.获取容器
				（spring）
			2.获取对象
				（jdbcTemplate）
			3.执行操作
				uodata
				query
		
			
		eg：
		//1.获取容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //2.获取对象
        JdbcTemplate jt = ac.getBean("jdbcTemplate",JdbcTemplate.class);
        //3.执行操作
        //保存
//        jt.update("insert into account(name,money)values(?,?)","eee",3333f);
        //更新
//        jt.update("update account set name=?,money=? where id=?","test",4567,7);
        //删除
//        jt.update("delete from account where id=?",8);
        //查询所有
//        List<Account> accounts = jt.query("select * from account where money > ?",new AccountRowMapper(),1000f);
//        List<Account> accounts = jt.query("select * from account where money > ?",new BeanPropertyRowMapper<Account>(Account.class),1000f);
//        for(Account account : accounts){
//            System.out.println(account);
//        }
        //查询一个
//        List<Account> accounts = jt.query("select * from account where id = ?",new BeanPropertyRowMapper<Account>(Account.class),1);
//        System.out.println(accounts.isEmpty()?"没有内容":accounts.get(0));

        //查询返回一行一列（使用聚合函数，但不加group by子句）
        Long count = jt.queryForObject("select count(*) from account where money > ?",Long.class,1000f);
        System.out.println(count);	
	
		/**
		 * 账户的持久层实现类
		 */
		@Repository
		public class AccountDaoImpl2 implements IAccountDao {

			@Autowired
			private JdbcTemplate jdbcTemplate;


			@Override
			public Account findAccountById(Integer accountId) {
				List<Account> accounts = jdbcTemplate.query("select * from account where id = ?",new BeanPropertyRowMapper<Account>(Account.class),accountId);
				return accounts.isEmpty()?null:accounts.get(0);
			}

			@Override
			public Account findAccountByName(String accountName) {
				List<Account> accounts = jdbcTemplate.query("select * from account where name = ?",new BeanPropertyRowMapper<Account>(Account.class),accountName);
				if(accounts.isEmpty()){
					return null;
				}
				if(accounts.size()>1){
					throw new RuntimeException("结果集不唯一");
				}
				return accounts.get(0);
			}

			@Override
			public void updateAccount(Account account) {
				jdbcTemplate.update("update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId());
			}
			
		优化：
			实现类的代码有冗余  
			1.可以使用父类抽取相同的代码，其余实现类去继承
			2.也可以使用继承spring提供的类的方法来减少重复代码
		注意：如果采用注解配置，则使用继承   如果使用配置 则用继承的方法
		
	AOP实现事务控制和spring实现事务控制，，全注解使用事务
		AOP：
			 1.配置事务管理器（需要注入哟个类）
			 2.配置aop
				a.切点表达式
				b.配置切面（开启 提交 回滚 释放连接 ）
				
		spring实现事务的控制：
			1。配置pom ，打包方式，导入spring容器jar包 
				导入spring-jdbc，导入spring-tx，导入数据库连接mysql-connector-java
				导入aspectjweaver
			2.准备代码（jdbctemp的）（事务控制是在业务层的）
				（如果要用jnit，需要导包两个  junit 和spring-text）
			3.代码整个拷贝在05xml里   事务的配置建议使用xml来配置
			
		全注解使用事务：（事务的配置建议使用xml来配置）
		
	补充：
		切换jdk：
			1.1.  file---文件结构--文件--文件sdk和文件语言等级  选1.7和7              
			2.   file---文件结构--模板--资源  --语言等级                       1.7          
			3.file--setting---构建 执行 部署  --compiler --java compiler--target bytecode version 选1.7
			
		
SpringMVC：（重点：入门程序的步骤  参数绑定和常用注解也很重要）

	知识点：
		1.服务器端的三层框架
			表现层（SpringMVC） 业务层(Spring) 持久层（Mybatis）
			
		2.MVC设计模式：
			M model 模型  javabean
			V view  视图  HTML （JSP）
			C Controller 控制器 servlet
		SpringMVC 与 Struts2 的共同点和区别：
			共同点：
				他们都是表现层框架
				底层都离不开原始的servleAPI
				* 处理请求的机制都是一个核心控制器
			区别：
				* Spring MVC 的入口是servlet struts2是Filter
				* 前者是基于MVC设计的 后者是基于类设计的 
				  Struts2每次执行都会创建一个动作类 所以速度会比较慢
				* MVC使用更加简洁 支持JSR303 处理ajax的请求更方便  
				* 后者的PGNL表达式使得页面开发效率比MVC更高一些 但执行执行效率没有比JSTL提升
					尤其是struts2的表单属性 远没有html的执行效率高
			
		流程：基于组件方式执行流程 
			前端请求――――》	
			前端控制器（dispatcheServlet）――――》 
			处理器映射器（HandMapping）（Controller类的方法）―――》返回前端控制器――――》
			
			处理器适配器（HandlerAdaptter）――――》
				处理器（Controller）――――》
					返回success.jsp 到处理器适配器――――》返回到前端控制器――――》
			
			视图解析器――――》返回前端控制器――――》
			
			视图――――》前端控制器――――》
			
			response
			
		《mvc:annotation-driven》	
			mvc组件中  处理器映射器  处理器适配器（HandlerAdaptter   视图解析器称为spring、mvc三大组件
			使用该标签自动加载前两个组件


		
	环境搭建：
		1.创建maven工程 选择webapp骨架    
		2.完善pom  改编译版本1.8    增加版本锁定    导入jar包。     
		3. 配置前端控制器（servlet） ：在web.xm中配置   
			<servlet><servlet-mapping>(DispatcherServlet)     
		4. 新建springmvc配置文件     
		5.配置tomcat
		
	代码编写：
		1.准备默认首页 提供一个连接
		2.新建一个控制器类（Contorller）
			写方法 返回字符串
			a.因为需要执行方法  所以需要把类变成对象（此时需要两个注解+配置ioc）
				springmvc.xml：   导入约束
								  开启注解扫描
									《contest：component-scan base-package=“”cn。itcast》
									
									给类加注解@Controller
									给方法加注解@RequestMapper（path=“hello”）
									
		3.在web.xml中的前端控制器servlet里  加一组全局变量
		
			《init-parm》
				<param-name>contestConfiglocation
				<param-value>classpath：配置文件名
			《/init》
			《load-on-statup》1
			
		4.提供jsp文件（在web-inf/pages下提供）
			
		
		5.配置视图解析器
			《bean id  class=“internalResourViewResolver”》
				《property name="prefix" value="文件路径" 》
				《property naem  value=".jsp" 》
		6.建议再配置开启springMVC框架的支持
			《mvc：annotation-driver》
	
	
	
	springmvc常用注解：
		@request  作用位置是参数
				属性： 
					name=“”（name的值和页面传过来的参数要一样）
					request：要求一定要有参数 且名字一样
		@requestBody （Ajax）
			位置：形参之前  表示把请求体复制给该参数
			（知乎有补充）
		@PathValue
			使用于rest风格：
			eg：
				后台控制器代码：
				@requestMapping("/testPathValue/{sid}")
				public String testPathValue(@PathValue(name="sid}") String id ){
				
				}
				前端页面代码：
					《a href=“anno/testPathValue/10”》《/a》
			
				不同方法的访问路径相同 以请求访问方式区分，或者携带别的参数 比如/user/{id}
		@过滤器可以改变请求方式（了解）
		@requestheader  获取请求头（用的不多）
		@cookieValue（用的不多）
			获取指定cookie的值
		@ModelAttribure
			位置：方法 参数（参数共享）
			方法：优先于控制器执行
			参数： 参数共享
		@SessionAttribute	
		eg：在方法使用 该方法封装了一个名为abc的user对象，放在map集合里
			在控制器方法的参数列表 可以使用该注释 根据key值来获取对应的user
			@modelAttribute（“abc”）
		
	


		
	配置中文乱码过滤器：
		1.web。xml中配置
			《filter》
				《filter-name》
				《filter-class》org.springframework.web.filter.CharacterEncodingFilter
			《filter-mapper》
				《filter-name》
				《url-pattern》/*
		2.提供参数
			在filter-class下提供
				《init-param》
					《param-name》encoding
					《param-value》UTF-8
		
	请求参数封装到集合：
		前端代码：标签的name=“list【0】.
		
	自定义类型转换器：
		1.新建包和类  实现Conveter  实现方法
		2.配置类型转换器（spring给的类 需要注入自己写的类）

	获取原生的API:在参数列表中添加
		
	响应数据和结果视图
	
	   1.前端获取后台数据	${user.username}
		后台需要model。addAttribute（“user”，user）	
		（前端发请求    后台封装到Model对象里   对象自动存放到request域里     然后 转发到页面  页面再取值  以后常用的开发方式）
		上面是 返回字符串类型
	
	   2. 返回ModelAndView
			用法：1.mv.addObject（）	//把对象
				  2.mv.setViewName("success")
				  3.retrun mv
				把对象存入mv对象中  mv对象会把对象存入request对象中
				然后设置跳转页面    返回mv对象
				
	   3.请求转发：
			return “forward：/WEB-INF/pages/success.jsp”；
	   
	   4.重定向：
			return：“redirect：/index.jsp”；
			
	   5.@ResponseBody注解
			响应jsion数据
						在后台的参数前使用  表示接受的数据类型是json
						在方法返回值前使用  表示返回的类型是json数据类型
			补充：json需要的jar包：jackson-annotation-2.90
									jackson-databind-2.90
									jackson-core-2.9.0
			
	   6.配置前端控制器：
			作用：保护一些资源不被拦截
			过程：
				直接使用标签
					<mvc:resource location="/css/" mapping="/css/**">
	   7.开启springMVC框架注解的支持
			<mvc:annotation-driven/>
	   
	   8.前端解析json数据的代码：
			 // 页面加载，绑定单击事件
			$(function(){
				$("#btn").click(function(){
					// alert("hello btn");
					// 发送ajax请求
					$.ajax({
						// 编写json格式，设置属性和值
						url:"user/testAjax",
						contentType:"application/json;charset=UTF-8",
						data:'{"username":"hehe","password":"123","age":30}',
						dataType:"json",
						type:"post",
						success:function(data){
							// data服务器端响应的json的数据，进行解析
							alert(data);
							alert(data.username);
							alert(data.password);
							alert(data.age);
						}
					});

				});
			});
	   
	   
	springMVC上传文件：（案例有代码）
		前提：1.表单的enctype类型取值必须是：multipart/form-data
				该类型是表单请求正文的类型
			  2.method属性的取值必须是post
			  3.《input type=“file”/》			  
			  4. 两组jar包
					commons-fileupload
					conmons-io
		过程：1.搭建环境 新建web项目（骨架）  加一组键值对  
				配置pom  编译版本改1.8       
				在web.xml配置 前端控制器（复制）         
				提高springmvc配置文件（完善文件结构）   
				写页面（重写jsp    和控制器）         
				控制器写方法（加两个注解） 
				写解析器跳转的页面        
		
		配置文件上传解析器
			见代码
		需要导入jar包：  jersey-core   jerser-client
		补充：如果没有创建文件夹得代码 则需要自己在target目录里面的某个位置创建   否则会报409的错
		archetypeCatalog   internal
	
	异常处理：
		搭建：1. 导入jar包    2. web。xml配置前端控制器    3.提高springmvc配置文件
		演示异常处理
		首页写完  再补一个给解析器跳转的success。jsp就可以开始测试了（开启服务器）
		异常处理器组件
		写异常处理器
		配置异常处理器（自己的类写入容器）
		注意前端的代码  页面的java后 需要加一个属性 isELIgnnored=“false"
	拦截器：
		1.编写拦截器类 实现接口HandleInterceptor
		2.配置拦截器
	springmvc配置拦截器：（ctral+0   重写方法）
		<mvc:interceptors>
			<mvc:interceptor>
				<mvc:mapping path="">     //要拦截的具体方法
				//《mvc:exclude-mapping path=""》
				<bean class=”“>			 //配置拦截对象
				
	HandlerInterceptor接口中的方法 
		1. preHandle方法是controller方法执行前拦截的方法. 
			1.可以使用request或者response跳转到指定的页面 
			2. return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 
			3. return false不放行，不会执行controller中的方法。 
		2. postHandle是controller方法执行后执行的方法，在JSP视图执行前。
			1. 可以使用request或者response跳转到指定的页面 
			2. 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 
		3. postHandle方法是在JSP执行后执行 
			1. request或者response不能再跳转页面			
	
	
SSM框架整合：（必须会）（代码有完整的ssm）
	思路：1.搭建开发环境 其中三个个环境需要先搭建 保证可以独立运行 之后开始整合   另外两个向spring整合
		  2.springmvc整合  需要考虑的问题是
				网页请求时  业务层需要ioc容器的对象  此时spring没有加载spring配置文件 不会创建容器
				所以需要在web.xml中配置监听器  监听服务器某个对象的创建 创建时加载spring配置文件
		  3.Mybatis与spring的整合 需要考虑的问题是	
				业务层需要能够调用dao  dao对象存入容器
				把sqlnapConfig配置文件的配置转移到spring的配置文件（配置后sqlmapc配置文件可以删掉）

	整合步骤：
		1.搭建spring开发环境（业务层框架）
				1.maven工程   导入jar包    导入配置    导入log4j
				2.写实体类（javabean）（实现接口）
				3.写实体类接口  
					@Repository
					@Select
				4.写service层接口
					
				5.service实现类
					@Service
					注入dao@Autowired （service里需要调用dao的方法 所以需要dao实现类的对象 ）
					
				6.写前端控制器	
					本质时servlet，作用是接受前端的请求路径，路径对应方法
					@Controller
					@RequestMapping  一般是二级结构 类一级 方法一级
					@Autowired    （控制器有时候需要调用业务层的方法  所以需要service对象 用注解注入）
				
				7.写spring配置文件
					1.导入约束   2.开启扫描（控制器类不扫描）   
						<context:component-scan base-package="cn.itcast">
							<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
						</context:component-scan>
				8.测试	（此时没有注入dao  只是验证业务层环境是否搭建成功）
					//加载配置文件
					ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("classpath:applicationcontext.xml");
					//获取对象
					IAccountService as =(IAccountService) ac.getBean("accountService");
					//执行
					as.findAll();
				
		2.搭建springMVC环境
				1.配置前端控制器（配置servlet DispatcherServlet 多一步加载mvc配置文件 load-on-startup）（web。xml）
						<servlet>
							<servlet-name>dispatcherServlet</servlet-name>
							<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
							<!--加载springmvc.xml配置文件-->
							<init-param>
								<param-name>contextConfigLocation</param-name>
								<param-value>classpath:springmvc.xml</param-value>
							</init-param>
							<!--启动服务器，创建该servlet-->
							<load-on-startup>1</load-on-startup>
						</servlet>
						<servlet-mapping>
							<servlet-name>dispatcherServlet</servlet-name>
							<url-pattern>/</url-pattern>
						</servlet-mapping>
				2.写springmvc配置文件
						1.开启注解扫描
							<!--开启注解扫描-->
							<context:component-scan base-package="cn.itcast">
								<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
							</context:component-scan>
							
						2.<!--配置视图解析器-->
							<bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
								<property name="prefix" value="/WEB-INF/pages/"/>
								<property name="suffix" value=".jsp"/>
							</bean>
							
						3.<!--过滤静态资源-->
							<mvc:resources location="/css/" mapping="/css/**" />
							<mvc:resources location="/images/" mapping="/images/**" />
							<mvc:resources location="/js/" mapping="/js/**" />
						
						4.<!--开启springmvc注解的支持-->
							<mvc:annotation-driven/>
						
				3.<!--解决中文乱码的过滤器-->（CharacterEncodingFilter）（web。xml）
						<filter>
							<filter-name>characterEncodingFilter</filter-name>
							<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
							<init-param>
								<param-name>encoding</param-name>
								<param-value>UTF-8</param-value>
							</init-param>
						</filter>
						<filter-mapping>
							<filter-name>characterEncodingFilter</filter-name>
							<url-pattern>/*</url-pattern>
						</filter-mapping>
				
				4.写前端页面开始测试
					注意：小节 前端控制器的本质是一个servlet（dispitureservlet） 
					所以配置前端控制器也就是配置这个servlet   其中遇到报错 
					把web配置文件的中文乱码过滤器注释掉就可以
				
		3 spring与springmvc的整合
				1. 开启服务器的时候 需要加载spring配置文件
					配置监听器加载spring配置文件（与配置servlet类似）
						<!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件-->
							<listener>
								<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
							</listener>
							<!--设置配置文件的路径-->
							<context-param>
								<param-name>contextConfigLocation</param-name>
								<param-value>classpath:applicationContext.xml</param-value>
							</context-param>
							
				2.实现依赖注入（业务层  这里指前端控制器  ）
					控制器类上注解 
						@Controller
						@RequestMapping("/account")
	
					成员对象 （业务层对象）AccountService
						@Autowired
						
					方法 （二级路径）
						 @RequestMapping("/findAll")
						
		4 搭建mybatis环境		
				1.给接口 写注解（也可以使用配置文件）
						@Select
					
				2. 编写mybatis核心配置文件（整合后需要删除  实际开发建议直接整合）
						
						三部分：约束 环境  映射
						<?xml version="1.0" encoding="UTF-8"?>
						<!DOCTYPE configuration
								PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
								"http://mybatis.org/dtd/mybatis-3-config.dtd">
						<configuration>
							<environments default="mysql">
								<environment id="mysql">
									<transactionManager type="JDBC"></transactionManager>
									<dataSource type="POOLED">
										<property name="driver" value="com.mysql.jdbc.Driver"/>
										<property name="url" value="jdbc:mysql:/3366/ssm"/>
										<property name="username" value="root"/>
										<property name="password" value="124546"/>
									</dataSource>
								</environment>
							</environments>

							<mappers>
								<package name="cn.itcast.dao"/>
							</mappers>
						</configuration>
				3.测试（记得除了查找的操作 其余的操作需要提交  否则操作成功 但是数据库没有保存）
						// 加载配置文件
						InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");
						// 创建SqlSessionFactory对象
						SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
						// 创建SqlSession对象
						SqlSession session = factory.openSession();
						// 获取到代理对象
							IAccountDao dao = session.getMapper(IAccountDao.class);
						// 查询所有数据
						List<Account> list = dao.findAll();
						for(Account account : list){
							System.out.println(account);
						}
						// 关闭资源
						session.close();
						in.close();
		
		spring与Mybatis整合：
				思想 ：service能够调用dao 换句话说  就是按mybatis测试时需要哪些类 把这些类加载到容器里
				分析：  service能够调用dao   dao的代理对象存入ioc容器
				
				步骤：
					1.整合两个的配置文件（spring里写mybatis的配置文件）
							1.配置来凝结池
									<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
										<property name="driverClass" value="com.mysql.jdbc.Driver"/>
										<property name="jdbcUrl" value="jdbc:mysql://localhost:3366/ssm"/>
										<property name="user" value="root"/>
										<property name="password" value="124546"/>
									</bean>
							2.配置sql工厂
									<!--配置SqlSessionFactory工厂-->
									<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
										<property name="dataSource" ref="dataSource" />
									</bean>
							3.配置接口所在的包
									<bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
										<property name="basePackage" value="cn.itcast.dao"/>
									</bean>
									
					2. 依赖注入
							业务层实现类 
								@Service("accountService")
							业务层实现类成员属性
								 @Autowired
								 
					3.添加声明式事务管理		 
							1.在spring配置里配置
									1. 配置事务管理器  《bean id   class=datasourcetransaction》  注入一个  数据源  
											<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
												<property name="dataSource" ref="dataSource" />
											</bean>
											
									2.事务的通知    《tx：advice》
											<tx:advice id="txAdvice" transaction-manager="transactionManager">
												<tx:attributes>
													<tx:method name="find*" read-only="true"/>
													<tx:method name="*" isolation="DEFAULT"/>
												</tx:attributes>
											</tx:advice>
											
									3.aop增强   
										《aop：config》       《》切入点表达式
										 <aop:config>
											<aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.itcast.service.Impl.*ServiceImpl.*(..))"/>
										</aop:config>


										
SpringBoot：	
			
		快速入门：
				1.创建maven
						添加两个起步依赖
								<!--所有的springboot工程都必须继承spring-boot-starter-parent-->
								<parent>
									<groupId>org.springframework.boot</groupId>
									<artifactId>spring-boot-starter-parent</artifactId>
									<version>2.0.1.RELEASE</version>
								</parent>
								<!--web功能的起步依赖-->
								<dependency>
									<groupId>org.springframework.boot</groupId>
									<artifactId>spring-boot-starter-web</artifactId>
								</dependency>		
								<!--热部署配置-->
								<dependency>
									<groupId>org.springframework.boot</groupId>
									<artifactId>spring-boot-devtools</artifactId>
								</dependency>
								
				2.写引导类（注解 调用run  参数是自身）
				
						@SpringBootApplication
						public class MySpringBootApplication {

							public static void main(String[] args) {
								SpringApplication.run(MySpringBootApplication.class);
							}
						}

				3.写前端控制器
						
						@RestController
						public class TestController {

							@RequestMapping("/quick")
							@ResponseBody
							public String quick(){

								return "nihao world";
							}
						}
						
				4.测试
						运行main函数  浏览器访问
				
				
			补充：
				热部署	：idea需要设置（原因是idea本身不支持，不是依赖jar的问题） 
							1. setting  执行 编译  的编译   自动构建 勾上    
							2  ctrl + shift+alt  + /    选Registry     
				
		使用idea快速创建springboot项目
				搭建后 引导类自动存在 搭建后 引导类自动存在
				
				新注解： @RestController
				springbootConfig注解相当于三个注解  扫描 自动注入   还有  容器
		
		配置文件：
			作用：
				覆盖默认配置   properties yml  yaml 2种配置文件
				位置  resources 创建application。xxx配置文件
				一般用yml就可以
			properties文件：    server.port=8081		
			
			yml：
				普通的数据 name： zhansan
				对象：
					person：
						name： zhansan
						age： 18
						address： beijing
					//person： {name： zhangsan，age： 18}
				配置数组：
					city：
						- beijing
						- tianjing
					//city： 【beijing，tianjing】
					
					students：
						- name： tom
						  age： 18
						- name： lucy
						  age： 17
					//students： 【{name： tom，age： 18}，{}】
					
				配置Map
					map:
						key1: value1
						key2: value2
				
				获取配置文件信息
					在属性前加@value属性
						@Value（“${naem}”）
						private String naem；
					
					在类上加@ConfigurationPropertise（需要提高getter和setter方法）
						@ConfigurationPropertise（prefix=“persion”）
						public class xxx（）{
						}
						
			配置执行器  防止报错		
					g org.springframework.boot
					a spring-boot-configuration-processor	
					<optional>true</>	
				配置后代码有提示
						
Springboot整合Mybatis和junit
		整合mybatis
			1.添加mybatis起步依赖
				<!--mybatis起步依赖--> 
				<dependency>
					<groupId>org.mybatis.spring.boot</groupId> 
					<artifactId>mybatis-spring-boot-starter</artifactId>  
					<version>1.1.1</version> 
				</dependency>
				
			2.添加数据库驱动坐标
				<!-- MySQL连接驱动 --> 
				<dependency> 
					<groupId>mysql</groupId>   
					<artifactId>mysql-connector-java</artifactId> 
				</dependency>
				
			3.添加数据库连接信息（在application.properties中添加数据）
				
				#DB Configuration: 
				spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver 
				spring.datasource.url=jdbc:mysql://localhost:3366/account?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC&useSSL=false
				spring.datasource.username=root 
				spring.datasource.password=124546
				
			4.创建数据库user表
				-- Table structure for `user` -- ---------------------------
				DROP TABLE IF EXISTS `user`; 
				CREATE TABLE `user` (  
				`id` int(11) NOT NULL AUTO_INCREMENT, 
				`username` varchar(50) DEFAULT NULL, 
				`password` varchar(50) DEFAULT NULL, 
				`name` varchar(50) DEFAULT NULL, 
				PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;
 
				-- ---------------------------
				-- Records of user -- ---------------------------
				INSERT INTO `user` VALUES ('1', 'zhangsan', '123', '张三'); 
				INSERT INTO `user` VALUES ('2', 'lisi', '123', '李四');

			5.创建实体类 编写接口dao（usermapper）
				    // 主键  
					private Long id;   
					// 用户名   
					private String username;    
					// 密码 
					private String password;   
					// 姓名  
					private String name;
					
			6.配置mapper文件（下加入UserMapper.xml配置文件"）
				
				<?xml version="1.0" encoding="utf-8" ?>
				<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
				"http://mybatis.org/dtd/mybatis-3-mapper.dtd" > 
				<mapper namespace="com.itheima.mapper.UserMapper">  
					<select id="queryUserList" resultType="user">    
						select * from user 
					</select> 
				</mapper>
				
			7.在spring配置文件（properties）中添加mybatis配置信息
				
				#spring集成Mybatis环境
				#pojo别名扫描包 
				mybatis.type-aliases-package=com.itheima.domain 
				#加载Mybatis映射文件 
				mybatis.mapper-locations=classpath:mapper/*Mapper.xml
				
				
			8.写前端控制器（需要注解 ： @Controller @Autowired  @RequestMapping("/queryUser")  
					@ResponseBody ）
					
				@Controller 
				public class MapperController {
 
					@Autowired  
					private UserMapper userMapper;
 
					@RequestMapping("/queryUser")  
					@ResponseBody  
					public List<User> queryUser(){
					List<User> users = userMapper.queryUserList();
					
					return users;  
				}
 
}
			9.测试
		
		集成junit
			1.  导入起步依赖 
				
				<!--测试的起步依赖-->
				<dependency>  
					<groupId>org.springframework.boot</groupId> 
					<artifactId>spring-boot-starter-test</artifactId>    
					<scope>test</scope> 
				</dependency>
				
			2.  可以开始测试  
					@RunWith(SpringRunner.class)
					@SpringBootTest(classes = MySpringBootApplication.class) 
					public class MapperTest {
 
						@Autowired 
						private UserMapper userMapper;
 
						@Test  
						public void test() {     
							List<User> users = userMapper.queryUserList();    
							System.out.println(users);  
						}
 
					}
			其中，
				SpringRunner继承自SpringJUnit4ClassRunner
				使用哪一个Spring提供的测试测试引擎都可以
				
				public final class SpringRunner extends SpringJUnit4ClassRunner 
				
				@SpringBootTest的属性指定的是引导类的字节码对象
				
				
			注意：
					/**
					 * springboot整合junit
					 *  导入jar包 需要加两个注解
					 *      @RunWith(SpringRunner.class)
					 *      @SpringBootTest
					 *    两个注解都要加载类上，且只能在测试类里测试
					 */
					 
					 
					 
框架一轮复习：
	mybatis
		resultmap：
		
		
	spring
		DI的注入方式建议写一个demo
		
		用于创建对象的注解
			Component:
				作用：用于把当前类对象存入spring容器中
				属性：
					value：用于指定这个对象（bean）的id  默认是当前类名，首字母小写
			Controller: 一般用在表现层
			
			Service: 一般用在服务层
			Repository:一般用在持久层
			上面四个注解的后三个的作用和属性与第一个一模一样
			
			
		用于注入数据的注解：
			Autowrite
			Resource
			还有一个quilyfile不常用

		Value:
			作用：注入基本数据类型和String类型
			属性：	
				value：用于指定数据的值，也可以使用spring中的sqEL
				sqEL写法： ${表达式}
				
		注解开发的注解还没有整理
		
		spring的全注解配置需要加强  看有无需要  （应该不需要 springboot 里面的spring配置是基于xml的）	
			
		aop建议二刷

		全通配写法：
                    * *..*.*(..)
			
		实际开发中切入点表达式的通常写法：
                    切到业务层实现类下的所有方法
                        * com.itheima.service.impl.*.*(..)	
			
		spring实现事务的控制：
			1。配置pom ，打包方式，导入spring容器jar包 
				导入spring-jdbc，导入spring-tx，导入数据库连接mysql-connector-java
				导入aspectjweaver
			2.准备代码（jdbctemp的）（事务控制是在业务层的）
				（如果要用jnit，需要导包两个  junit 和spring-text）
			3.代码整个拷贝在05xml里   事务的配置建议使用xml来配置		
			
		（springmvc往后的内容没有复习）
		
		
国庆三天学linux（Linux笔记）（账号：124546  密码：xie124546）
		1.安装linux系统
		2.调整内存（其中图形界面有最小内存要求）
		3.调整光盘映像
		4.快照
		5.克隆（真实机的映像  连接克隆  完全克隆）
		6.
	系统分区
		主分区:
			最多四个
		扩张分区：
			最多一个
			不能写入数据 只能包含逻辑分区
			主分区和扩张分区最多四个	
		
		逻辑分区：
	格式化：
		高级格式化：写入数据块
	
	分区设备文件名
		sda1
			硬盘接口
			
	* 挂载：
		必须分区：
			/
			swap（交换分区 内存的两倍）
			
		推荐分区：
			/boot（启动分区  200MB）（保存启动的时候需要的数据 以后不在里面写数据）
				（分区的好处 是当/分区写满的时候  还能启动系统）
			
	远程登陆管理工具：
		
		网络：
			桥接：利用真实网卡   虚拟机利用网卡和真实计算机进行联系  
					优点：1.配置简单
						  2.还能局域网内的计算机进行交互
					缺点：占用网段的地址 ip地址冲突
						
			NAT:   使用vmarn8 假网卡 和真实机通信
					不占用网段的地址
					真实机可用联网 虚拟机也可以联网
					
			Host-only：  使用VMnat 1 网卡进行
							不占用网段的地址
						只能访问本真实机
						
				1.用host-only与本机通行
					1.查看 vmnat1  的虚拟ip地址（因为host-onlu就是利用这个虚拟网卡来进行通信的）
					2.linux系统 增加一个虚拟ip地址
						使用的命令
							ifconfig		//查看ip
							ifconfig 192.168.117.1          //增加ip
					3.本机虚拟终端 
							ping这个ip地址
								接受到数据包 则表示成功
				
				2.利用桥接模式
					1. 查看本机网络的ip地址  
					2. 增加虚拟机的ip地址
					3.真实计算机去ping这个ip地址
					有接收包则成功
					
				     注意：linux配置的ip是暂时性的  ip地址会丢失
							（永久的话 需要修改配置文件）
							
						如果失败的话，原因可能是应为本机网卡有有线和无线两个
						虚拟机自动连接到另外一个了  去虚拟机更一下连接设置即可
					
				3。两个常用的工具
				
	初学者注意事项			：
		1. linux严格区分大小写
		2. Linux的硬件都以文件形式存储（操作和管理）
			也就是说 要操作硬件需要通过操作软件
		3.linux不是靠扩张名区分文件类型的（靠的是文件权限）
			压缩包：  .gz     .bz2     .tar.bz2    .tgz
			二进制包：.rpm
			网页文件：.html       .php
			脚本文件：.sh
			配置文件：.conf
			
			注意：扩展名是方便管理员管理和辨别文件的  不写系统也可以识别是什么类型的文件
		4.Linux所有的存储设备都必须先挂在 之后才能使用 包括硬盘 u盘 和光盘
		  挂载：   设备都有名称 叫设别文件名     挂载点（盘符来理解）     
					把设备文件名和挂载点连接起来的过程 叫做 挂载
					
				window的挂载是自动执行的
		5.windows下的程序 不能直接在Linux中安装和运行 (不同的操作系统)
		
		6.linux各个目录的作用：
			
			命令对linux来讲就是一个可执行的二进制文件
				bin
			1./bin/
				任何用户都可以执行
			2./sbin/
				只有root才能执行
			3./usr/bin/
				单用户
			4./suser/bin/
				只有root
			5./boot/
				单独分区  启动的相关信息（备份）
			6./dev/
				保存硬件的设备文件
			7./etc/
				默认配置文件的保存位置（系统备份）
			
			8. /home/  
				存放用户的信息 在该目录下新建一个和用户名相同的目录
			9. /lib/
					系统调用的函数库的位置
			10. /lost+found
					文件碎片
					断电的时候有用（检测修复）
					每个分区都有
			11. /media/
					挂载多媒体
			12. /mnt/
					
			14. /mist/
					ns服务的共享目录			
			13. /opt/
					第三方的安装包
			14./proc/
					存放在内存中 不可往里面写东西
					存放进程信息 硬件设备信息
			15./sys/
					存放在内存中 不可往里面写东西
			16./root/
			
			17./srv/
			
			18./tmp/

			19./usr/
			
			20./var/
			
		7.服务器不关机 只重启	
		8.重启时  应该关闭服务	
			
	基本命令：
		pwd
		rouch
		ls
		rm filename
		rm filename -rf
		clean
		mkdir filename 
		cp filename tmp   //拷贝文件到tmp
		mv filename newfilename  //重命名
		cat filename    
		||
		vi filename
		vim filename
		cd /   	回到根目录
		vim tfy.cfg      //?
		i
		esc      //不可编辑
		dd		//删除当前行
		zdd
		yy		//复制
		tyy
		p		//粘贴
		x       //删除光标字符
		V		//撤回
		：20     //到20行
		G		//最后
		gg       //最开始
		：set number		
		: set no number
		/lang 回车     //重载
		n			//往下查找
		N       //往上查找
		：w       //保存
		：wq		//保存并退出
		：q！		//强制退出不保存
		vigr		//查看所有的组
		vipw		//查看所有的用户
		ipconfig	//查看ip地址信息
		dhclient	//分配动态ip
		ping 		//检测网络是否通顺
			eg：ping www.baidu.com
		shut down   //安全关机
		reboot 		//重启
		logout		//注册
		
		2.文件操作：
			etx		//配置信息
			home	//
			usr
			root
			tmp
			var
			
		cd   
			eg：
				cd /tem             //到根目录的tmp
				cd tmp           //到当前目录的tem
				
		ll		//与ls相似    比ls多用户权限
		cp /etc/a /usr/        //把a文件复制到usr目录下
		mv a.txt ../lws/abc 	//把a移动到相对路径lws下并命名为abc
		
		rm -r      //递归删除，可删目录
		rm -f 		//强制删除  不提示 忽略是否存在
		rm -rf 		//
		
		more/less	//查看文件内容
		head
			eg： head filename		  //查看文件
				 head -n filename    //查看文件的前n行
		tail
		grep       //模糊搜索
		find  目录 -name  “文件格式”  
			eg：
				find /tmp -name "c*"
		3.管道命令
			>		//文件内容覆盖
			>>		//追加
			命令1 | 命令2    //执行命令一的结构作为命令2的目录
				eg：
					ps -ef | grep java
		4.连接
			ln 创建连接
				eg：
					ln -s a.txt b.txt	//b为a的软连接（快捷键）
					ln a.txt b.txt      //创建软连接
		5.
			vi
			:wq
			:wq!
			:q
			ndd 	//删除n行
			nyy 	//复制n行
			p		//粘贴 光标之下 
			P 		//张贴 光标之上
			
		二：权限管理
			1.用户和组
				U   G   O
				根据  R  读
					  W  写
					  X  可执行
					  
				1.）文件的权限标识分析
					drwxr-xrxx
						d表示文件  -表示目录
						后三个三个为一组  分别为U G O的权限
						
				2.）修改权限
					修改权限
						* 通过”=“修改
						
						* 通过”+“修改
						
						* 通过 数字分配
						
				3.）修改文件所有者
					chown root a.txt
					
				4.）修改文件所属组
				
			3.压缩和解压文件
		
		
JavaWeb笔记（二刷）（idea test）
	
	服务器软件
		* 服务器 安装的服务器软件的计算机（配置高）（mysql服务器  web服务器）
		* 服务器软件：接受用户请求  处理请求 做出响应 
		* Web服务器软件：接受用户请求  处理请求 做出响应 
			在web服务器软件中 可以部署一些项目 让用户通过浏览器来访问
			web容器
		* 常见的java相关的web服务器软件：
			* weblogic：oracle   大型的javaEE服务器 支持所有javaEE规范  收费
			* webSphere：IBM公司 大型的javaEE服务器   支持所有javaEE规范  收费
			*JBOSS ：JBOSS公司 大型的javaEE服务器  支持所有javaEE规范  收费
		
		* javaEE  java语言在企业开发中的使用技术规范的总和   一定规定了13大项的规范
		
		
		
	软件架构
		C/S		客户端/服务器
		B/S		浏览器/服务器
		
	资源分类
		1. 静态资源：所有用户访问得到的资源都一样（html，css，js）
					 * 被访问时 可以直接返回给浏览器  直接被浏览器解析
					 
		2. 动态资源：每个用户访问相同的资源后得到的结果不一样  
					（servlet jsp   php  sap）
					 * 被访问时 需要转换为静态资源再返回给浏览器
			请求： 
			响应：服务器返回数据的过程
			
	网络通信三要素
		1.ip：电子设备（计算机）在网罗中的唯一标识。
		2.端口：应用程序在计算机中的唯一标识（0~65536）
		3.传输协议：规定数据传输的规则
			1.基础协议
				1.tcp 安全协议 三次握手  速度慢
				2.udp 不安全协议  速度快
	#Tomcat：web服务器软件
		1.下载： 官网即可
		2.安装： 解压缩包即可
		3.卸载： 删除目录
		4.启动：
			* bin/statup.bat
			* 访问：浏览器输入：http：//localhost：8080
			
			可能遇到的问题：
				1.黑窗口：没有正确配置JAVA_HOME环境变量
				2.启动报错：
					修改自身端口号
					一般修改为80  访问时可以省略
		5.关闭
			正常：	
				1.ctrl+c
				2.bin/shutdown.bat
			强制：
				点击右上角的x
			
		6.配置
			有三种
				开发人员只需要了解直接放在webapps下的这种
					1.简化 直接打成war包  放在webapps下（会自动解压）
					
	###Servlet
		概念：运行在服务器端的小程序
			* servlet就是一个接口 定义了java类能被浏览器访问到（服务器识别）的规则
			* servlet是由tomcat执行的
		入门：
			新建一个类（EE项目） 实现servlet  web。xml中配置 servlet 即可访问
				
	

## Servlet：
	1. 概念
	2. 步骤
	3. 执行原理
			1.服务器接收到哭护短浏览器的请求后  会解析URL路径  获取访问的servlet路径
			2.查找web.xml文件   查看是否有servlet对应的类字节码
			3.有则找到全类名
			4.服务器会加载字节码文件进内存   并创建对象
			5.调用方法
			
	4. 生命周期
			1. 被创建：执行init方法，只执行一次
				* Servlet什么时候被创建？
					* 默认情况下，第一次被访问时，Servlet被创建
					* 可以配置执行Servlet的创建时机。
						* 在<servlet>标签下配置
							1. 第一次被访问时，创建
								* <load-on-startup>的值为负数
							2. 在服务器启动时，创建
								* <load-on-startup>的值为0或正整数


				* Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
					* 多个用户同时访问时，可能存在线程安全问题。
					* 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值

			2. 提供服务：执行service方法，执行多次
				* 每次访问Servlet时，Service方法都会被调用一次。
			3. 被销毁：执行destroy方法，只执行一次
				* Servlet被销毁时执行。服务器关闭时，Servlet被销毁
				* 只有服务器正常关闭时，才会执行destroy方法。
				* destroy方法在Servlet被销毁之前执行，一般用于释放资源
	5. Servlet3.0 注解配置
			* 好处：
			* 支持注解配置。可以不需要web.xml了。

			* 步骤：
				1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml
				2. 定义一个类，实现Servlet接口
				3. 复写方法
				4. 在类上使用@WebServlet注解，进行配置
					* @WebServlet("资源路径")


					@Target({ElementType.TYPE})
					@Retention(RetentionPolicy.RUNTIME)
					@Documented
					public @interface WebServlet {
						String name() default "";//相当于<Servlet-name>
					
						String[] value() default {};//代表urlPatterns()属性配置
					
						String[] urlPatterns() default {};//相当于<url-pattern>
					
						int loadOnStartup() default -1;//相当于<load-on-startup>
					
						WebInitParam[] initParams() default {};
					
						boolean asyncSupported() default false;
					
						String smallIcon() default "";
					
						String largeIcon() default "";
					
						String description() default "";
					
						String displayName() default "";
					}
			## IDEA与tomcat的相关配置
				1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件
					* 查看控制台的log：Using CATALINA_BASE:   "C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast"

				2. 工作空间项目    和     tomcat部署的web项目
					* tomcat真正访问的是“tomcat部署的web项目”，"tomcat部署的web项目"对应着"工作空间项目" 的web目录下的所有资源
					* WEB-INF目录下的资源不能被浏览器直接访问。
				3. 断点调试：使用"小虫子"启动 dubug 启动
				
	6. Servlet的体系结构	
		Servlet -- 接口
			|
		GenericServlet -- 抽象类
			|
		HttpServlet  -- 抽象类

		* GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象
			* 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可

		* HttpServlet：对http协议的一种封装，简化操作
			1. 定义类继承HttpServlet
			2. 复写doGet/doPost方法
	
	7. Servlet相关配置
		1. urlpartten:Servlet访问路径
			1. 一个Servlet可以定义多个访问路径 ： @WebServlet({"/d4","/dd4","/ddd4"})
			2. 路径定义规则：
				1. /xxx：路径匹配
				2. /xxx/xxx:多层路径，目录结构
				3. *.do：扩展名匹配

## HTTP：
	* 概念：Hyper Text Transfer Protocol 超文本传输协议
		* 传输协议：定义了，客户端和服务器端通信时，发送数据的格式
		* 特点：
			1. 基于TCP/IP的高级协议
			2. 默认端口号:80
			3. 基于请求/响应模型的:一次请求对应一次响应
			4. 无状态的：每次请求之间相互独立，不能交互数据

		* 历史版本：
			* 1.0：每一次请求响应都会建立新的连接
			* 1.1：复用连接

	* 请求消息数据格式
		1. 请求行
			请求方式 请求url 请求协议/版本
			GET /login.html	HTTP/1.1

			* 请求方式：
				* HTTP协议有7中请求方式，常用的有2种
					* GET：
						1. 请求参数在请求行中，在url后。
						2. 请求的url长度有限制的
						3. 不太安全
					* POST：
						1. 请求参数在请求体中
						2. 请求的url长度没有限制的
						3. 相对安全
		2. 请求头：客户端浏览器告诉服务器一些信息
			请求头名称: 请求头值
			* 常见的请求头：
				1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息
					* 可以在服务器端获取该头的信息，解决浏览器的兼容性问题

				2. Referer：http://localhost/login.html
					* 告诉服务器，我(当前请求)从哪里来？
						* 作用：
							1. 防盗链：
							2. 统计工作：
		3. 请求空行
			空行，就是用于分割POST请求的请求头，和请求体的。
		4. 请求体(正文)：
			* 封装POST请求消息的请求参数的

		* 字符串格式：
			POST /login.html	HTTP/1.1
			Host: localhost
			User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
			Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
			Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
			Accept-Encoding: gzip, deflate
			Referer: http://localhost/login.html
			Connection: keep-alive
			Upgrade-Insecure-Requests: 1
			
			username=zhangsan	


	* 响应消息数据格式

 


## Request：
	1. request对象和response对象的原理
		1. request和response对象是由服务器创建的。我们来使用它们
		2. request对象是来获取请求消息，response对象是来设置响应消息
	
	2. request对象继承体系结构：	
		ServletRequest		--	接口
			|	继承
		HttpServletRequest	-- 接口
			|	实现
		org.apache.catalina.connector.RequestFacade 类(tomcat)

	3. request功能：
		1. 获取请求消息数据
			1. 获取请求行数据
				* GET /day14/demo1?name=zhangsan HTTP/1.1
				* 方法：
					1. 获取请求方式 ：GET
						* String getMethod()  
					2. (*)获取虚拟目录：/day14
						* String getContextPath()
					3. 获取Servlet路径: /demo1
						* String getServletPath()
					4. 获取get方式请求参数：name=zhangsan
						* String getQueryString()
					5. (*)获取请求URI：/day14/demo1
						* String getRequestURI():		/day14/demo1
						* StringBuffer getRequestURL()  :http://localhost/day14/demo1

						* URL:统一资源定位符 ： http://localhost/day14/demo1	中华人民共和国
						* URI：统一资源标识符 : /day14/demo1					共和国
					
					6. 获取协议及版本：HTTP/1.1
						* String getProtocol()

					7. 获取客户机的IP地址：
						* String getRemoteAddr()
					
			2. 获取请求头数据
				* 方法：
					* (*)String getHeader(String name):通过请求头的名称获取请求头的值
					* Enumeration<String> getHeaderNames():获取所有的请求头名称
				
			3. 获取请求体数据:
				* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
				* 步骤：
					1. 获取流对象
						*  BufferedReader getReader()：获取字符输入流，只能操作字符数据
						*  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
							* 在文件上传知识点后讲解

					2. 再从流对象中拿数据
				
				
		2. 其他功能：
			1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数
				1. String getParameter(String name):根据参数名称获取参数值    username=zs&password=123
				2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&hobby=game
				3. Enumeration<String> getParameterNames():获取所有请求的参数名称
				4. Map<String,String[]> getParameterMap():获取所有参数的map集合

				* 中文乱码问题：
					* get方式：tomcat 8 已经将get方式乱码问题解决了
					* post方式：会乱码
						* 解决：在获取参数前，设置request的编码request.setCharacterEncoding("utf-8");
			
					
			2. 请求转发：一种在服务器内部的资源跳转方式
				1. 步骤：
					1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)
					2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 

				2. 特点：
					1. 浏览器地址栏路径不发生变化
					2. 只能转发到当前服务器内部资源中。
					3. 转发是一次请求


			3. 共享数据：
				* 域对象：一个有作用范围的对象，可以在范围内共享数据
				* request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
				* 方法：
					1. void setAttribute(String name,Object obj):存储数据
					2. Object getAttitude(String name):通过键获取值
					3. void removeAttribute(String name):通过键移除键值对

			4. 获取ServletContext：
				* ServletContext getServletContext()
			



## 案例：用户登录
	* 用户登录案例需求：
		1.编写login.html登录页面
			username & password 两个输入框
		2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表
		3.使用JdbcTemplate技术封装JDBC
		4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您
		5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误


	* 分析

	* 开发步骤
		1. 创建项目，导入html页面，配置文件，jar包
		2. 创建数据库环境
			CREATE DATABASE day14;
			USE day14;
			CREATE TABLE USER(
			
				id INT PRIMARY KEY AUTO_INCREMENT,
				username VARCHAR(32) UNIQUE NOT NULL,
				PASSWORD VARCHAR(32) NOT NULL
			);

		3. 创建包cn.itcast.domain,创建类User
			package cn.itcast.domain;
			/**
			 * 用户的实体类
			 */
			public class User {
			
			    private int id;
			    private String username;
			    private String password;
			
			
			    public int getId() {
			        return id;
			    }
			
			    public void setId(int id) {
			        this.id = id;
			    }
			
			    public String getUsername() {
			        return username;
			    }
			
			    public void setUsername(String username) {
			        this.username = username;
			    }
			
			    public String getPassword() {
			        return password;
			    }
			
			    public void setPassword(String password) {
			        this.password = password;
			    }
			
			    @Override
			    public String toString() {
			        return "User{" +
			                "id=" + id +
			                ", username='" + username + '\'' +
			                ", password='" + password + '\'' +
			                '}';
			    }
			}
		4. 创建包cn.itcast.util,编写工具类JDBCUtils
			package cn.itcast.util;

			import com.alibaba.druid.pool.DruidDataSourceFactory;
			
			import javax.sql.DataSource;
			import javax.xml.crypto.Data;
			import java.io.IOException;
			import java.io.InputStream;
			import java.sql.Connection;
			import java.sql.SQLException;
			import java.util.Properties;
			
			/**
			 * JDBC工具类 使用Durid连接池
			 */
			public class JDBCUtils {
			
			    private static DataSource ds ;
			
			    static {
			
			        try {
			            //1.加载配置文件
			            Properties pro = new Properties();
			            //使用ClassLoader加载配置文件，获取字节输入流
			            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");
			            pro.load(is);
			
			            //2.初始化连接池对象
			            ds = DruidDataSourceFactory.createDataSource(pro);
			
			        } catch (IOException e) {
			            e.printStackTrace();
			        } catch (Exception e) {
			            e.printStackTrace();
			        }
			    }
			
			    /**
			     * 获取连接池对象
			     */
			    public static DataSource getDataSource(){
			        return ds;
			    }
			
			
			    /**
			     * 获取连接Connection对象
			     */
			    public static Connection getConnection() throws SQLException {
			        return  ds.getConnection();
			    }
			}
		5. 创建包cn.itcast.dao,创建类UserDao,提供login方法
			
			package cn.itcast.dao;

			import cn.itcast.domain.User;
			import cn.itcast.util.JDBCUtils;
			import org.springframework.dao.DataAccessException;
			import org.springframework.jdbc.core.BeanPropertyRowMapper;
			import org.springframework.jdbc.core.JdbcTemplate;
			
			/**
			 * 操作数据库中User表的类
			 */
			public class UserDao {
			
			    //声明JDBCTemplate对象共用
			    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
			
			    /**
			     * 登录方法
			     * @param loginUser 只有用户名和密码
			     * @return user包含用户全部数据,没有查询到，返回null
			     */
			    public User login(User loginUser){
			        try {
			            //1.编写sql
			            String sql = "select * from user where username = ? and password = ?";
			            //2.调用query方法
			            User user = template.queryForObject(sql,
			                    new BeanPropertyRowMapper<User>(User.class),
			                    loginUser.getUsername(), loginUser.getPassword());
			
			
			            return user;
			        } catch (DataAccessException e) {
			            e.printStackTrace();//记录日志
			            return null;
			        }
			    }
			}
		
		6. 编写cn.itcast.web.servlet.LoginServlet类
			package cn.itcast.web.servlet;

			import cn.itcast.dao.UserDao;
			import cn.itcast.domain.User;
			
			import javax.servlet.ServletException;
			import javax.servlet.annotation.WebServlet;
			import javax.servlet.http.HttpServlet;
			import javax.servlet.http.HttpServletRequest;
			import javax.servlet.http.HttpServletResponse;
			import java.io.IOException;
			
			
			@WebServlet("/loginServlet")
			public class LoginServlet extends HttpServlet {
			
			
			    @Override
			    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			        //1.设置编码
			        req.setCharacterEncoding("utf-8");
			        //2.获取请求参数
			        String username = req.getParameter("username");
			        String password = req.getParameter("password");
			        //3.封装user对象
			        User loginUser = new User();
			        loginUser.setUsername(username);
			        loginUser.setPassword(password);
			
			        //4.调用UserDao的login方法
			        UserDao dao = new UserDao();
			        User user = dao.login(loginUser);
			
			        //5.判断user
			        if(user == null){
			            //登录失败
			            req.getRequestDispatcher("/failServlet").forward(req,resp);
			        }else{
			            //登录成功
			            //存储数据
			            req.setAttribute("user",user);
			            //转发
			            req.getRequestDispatcher("/successServlet").forward(req,resp);
			        }
			
			    }
			
			    @Override
			    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			        this.doGet(req,resp);
			    }
			}

		7. 编写FailServlet和SuccessServlet类
			@WebServlet("/successServlet")
			public class SuccessServlet extends HttpServlet {
			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			        //获取request域中共享的user对象
			        User user = (User) request.getAttribute("user");
			
			        if(user != null){
			            //给页面写一句话
			
			            //设置编码
			            response.setContentType("text/html;charset=utf-8");
			            //输出
			            response.getWriter().write("登录成功！"+user.getUsername()+",欢迎您");
			        }
			
			
			    }		


			@WebServlet("/failServlet")
			public class FailServlet extends HttpServlet {
			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			        //给页面写一句话
			
			        //设置编码
			        response.setContentType("text/html;charset=utf-8");
			        //输出
			        response.getWriter().write("登录失败，用户名或密码错误");
			
			    }
			
			    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			        this.doPost(request,response);
			    }
			}



		8. login.html中form表单的action路径的写法
			* 虚拟目录+Servlet的资源路径

		9. BeanUtils工具类，简化数据封装
			* 用于封装JavaBean的
			1. JavaBean：标准的Java类
				1. 要求：
					1. 类必须被public修饰
					2. 必须提供空参的构造器
					3. 成员变量必须使用private修饰
					4. 提供公共setter和getter方法
				2. 功能：封装数据


			2. 概念：
				成员变量：
				属性：setter和getter方法截取后的产物
					例如：getUsername() --> Username--> username


			3. 方法：
				1. setProperty()
				2. getProperty()
				3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中			
				
				
	
	###response笔记
    1.重定向的方法：response.sentRedirect("资源路径");
        *补充：
            1.重定向特点：redirect
                1.地址栏发生改变
                2.重定向可以访问其他站点（服务器）的资源
               *3.重定向是两次请求。不能使用request来共享数据（request.setAttribute()和getAttribute())
            2.转发的特点：forward
                1.转发地址栏路径不变
                2.转发只能访问当前服务器
                3.转发只是一次请求，可以使用response来共享数据
    2.相对路径和绝对路径 (./为当前路径，可以省略  ../为上一级路径）
        1.相对路径：通过相对路径可以确定唯一资源
            * 如 ./index.html
            * 不以/开头，以.开头或者省略

            规则：找到当前资源与目标资源的相对位置关系
                * ./ 为当前路径，可以省略
                * ../为上一级路径
        *2.绝对路径：通过绝对路径可以确定唯一资源（推荐使用）
                * 如  ：http://localhost/day15/responseDemo2         /day15/responseDemo2
                * 以/开头的路径

            规则：判断定义的路径是给谁用的？判断请求从哪来
                * 客户端使用 ：需要加虚拟目录（项目的访问路径）
                    *建议虚拟目录动态获取 ：request.getContextPath()
                    *<a>,<form> 重定向...

                * 服务器使用 ：不需要加虚拟目录
                    *转发路径

    3.服务器发送数据到浏览器

         1.输出字符数据
            *步骤
              1.1.获取字符输出流
                PrintWriter pw = response.getWriter();
              1.2.输出数据
                pw.write("你好，hello");


            * 乱码 ： 用这行代码即可：response.setContentType("text/html;charset=utf-8");
                    浏览器默认字符集GBK（gb2312）
                    获取的字符流是tomcat给的，流的编码是ISO
                *解决方法：
                     1.2.1.获取流对象之前，设置为  utf-8
                      response.setCharacterEncoding("utf-8");

                    (建议用2)1.2.2.告诉浏览器服务器发送数据的编码
                     response.setHeader("content-type","text/html,charset=utf-8");
                     简单的代码：
                   * response.setContentType("text/html;charset=utf-8");

         2.输出字节数据
            *步骤
               2.1.获取字节输出流 ：ServletOutputStream ops = response.getOutputStream();
               2.2.输出数据 ：ops.write("输出字节流hahahah".getBytes("utf-8"));
                    *注意 ：
                        如果输出字节数据，服务器为告知浏览器字符集类型
                        getBytes()中可以空参，如果告知，则需要传递字符集类型作为字符串参数

    4.验证码
        4.1笔记：基本上都在CheckCodeDemo1和register。html里

    5.ServletContext对象
        1. 概念：代表整个web应用，可以和服务器来通信

        2. 对象的获取（2种方法ServletContextDemo1）

        3. 功能：
                 *获取MIME类型（demo2）：在互联网通行的过程中定义的一种文件数据类型
                    格式： 大类型/小类型  text/html   image/jpeg
                    获取 : String getmimetype(String file)

                 *域对象：数据共享（demo3和4）
                              1 setAttribute()
                              2 getAttribute()
                              3 removeAttribute()
                         对象范围
                 * 获取文件的真实（服务器）路径
                     1方法 getRealPath()demo5       
                      三种类型放置的情况,a.txt  b.txt   c.txt

                        * main里的东西最后放在WEB-INF的classes里

    6 案例：DownloadServletDemo1
        * 文件下载需求：
                1.页面显示超链接
                2.任何资源都必须弹出下载框
                3.完成图片文件下载

        * 分析：
            1.能解析则加载显示，不能解析则弹出下载框
            2.任何资源都必须弹出下载框
            3.使用响应头设置资源打开的方式
                * content-disposition:attachment;filename=xxx

        * 步骤：
            1.定义页面，编辑href属性，指向servlet，传递资源名称filename
            2.定义servlet
                1.获取文件名称
                2.使用字节输入流加载文件进内存
                3.指定response的响应头：content-disposition:attachment;filename=xxx
                4.将数据写出到response输出流


            问题
                中文问题
                解决方法：


###会话技术：

        1.会话：一次会话包含多次请求和响应
            * 一次会话：浏览器第一次给服务器发送请求，会话建立。直到有一方断开为止
        2.功能：在一次会话的范围内的多次请求间，共享数据
        3.方式：
            1.客户端会话技术：Cookie
            2 .服务端会话技术：Session

###Cookie
        1.概念：客户端会话技术，将数据保存到客户端

        2.快速入门(demo1和demo2)
            *使用步骤：
                1.创建Coolie对象，绑定数据
                    * new Cookie(String name,Stirng value);
                2.发送Cookie对象
                    *response.addCokie(Cookie cookie)
                3.获取Cookie，拿到数据
                    * Cookie [] request.getCookie
                * 注意：cooie值不能存在空格
            *同一浏览器才能进行会话

        3.原理
            * 基于响应头set-cookie和请求cookie实现

        4.cookie的细节
            1.一次可以发送多个cookie？
                *可以，创建多个对象，发送多次数据即可
            2.cookie在浏览器保存多长时间？
                * 默认情况下，浏览器关闭后，cookie数据被销毁
                * 持久化存储：
                    *setMaxAge(int seconds)
                        正数：
                        负数：默认值
                        0：删除cookie信息
            3.cookie能不能存中文？
                * tomcat 8 之前不能，需要转码
                      编码
                      转码
                * tomcat 8 之后可以

            4.cookie获取范围多大？
                1.  假设tomcat服务器中部署多个web项目，这些web项目的cookie能不能共享？
                     * 默认不能
                     * setPath(String path);
                        如果需要共享，则可设置path的值为“/”
                2.不同服务器共享之间的cookie？
                    *  setDomain(String path);设置一级域名相同，则可以
                        * setDomain(".baidu.com")那么。。。。。。。。。

        5.特点和作用
            1.cookie存储数据在客户端浏览器
            2.浏览器对于单个cookie的大小有限制（4kb）以及同一域名下的总cookie数量有限制（20个）
            *作用：1.coolie一般用与存储少量的不太敏感的数据
                    2.在不登陆的情况下，完成服务器对客户端身份的识别

        6.案例：记住上次的访问时间
            1.需求：
               1.访问一个servlet，如果是第一次访问，则提示你好，欢迎您
               2.如果不是第一次访问，则提示欢迎您。上次的访问时间为：
            2.分析：
                1.可以采用cookie来完成、=
                2.在服务区中的servlet判断是否有一个名为lastTime的cookie
                    1.有：
                        1.响应数据欢迎，上次时间为
                        2.写回cookie
                    2.没有
                        1.响应数据，你好欢迎
                        2.写回cookie

###JSP 入门学习
    1.概念：
        * Java Server Pages :java服务器端页面
            *可以理解为一个特殊的页面，其中既可以定义html标签，又可以定义java代码
            * 可以简化书写

    2. 原理
        *JSP本质是一个Servlet

    3.JSP脚本：JSP定义Java代码的方式
        1.<%   代码 /%> 在service中
        2.<%！ 代码 /%> 在类成员
        3.<%=  代码 /%> 在输出语句中

    4.JSP的内置对象 ：
        *在JSP页面中不需要获取和创建，就可以直接使用的对象
        *JSP一共有九个内置对象
        *先学三个
            *request
            *response
            *out：
                *区别：response.getWriter()和out。write（）
                *先response再out
                *response永远在out之前
    5.JSP改造登录案例案例  home.jsp

###Session：
    1.概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端对象中。HttpSession
    2.快速入门：（demo1）
        1. 获取HttpSession对象：
            HttpSession session = request.getSession();
        2.使用HttpSession对象：
            Object getAttribute(String name)
            void setAttribute(String name, Object value)
            void removeAttribute(String name)
        3.原理
            * Session的实现是依赖Cookie的

        4.细节：
            1当客户端关闭后，服务器不关闭，两次session是否为同一个？
                * 默认情况下，不是
                * 如果需要，则可以创建cookie，键为SESSIONID，设置最大存活率，让cookie持久化保存
                    Cookie c = new Cookie("SESSIONID",session.getID());
                    c.setMaxAge(60*60);
                    response.addCookie(c);

            2. 客户端不关闭，服务器关闭后，两次获取的cookie是同一个吗？
                * 不是，但是要确保数据不丢失
                    * session的钝化：
                        在服务器正常关闭后，将session的对象系列化到硬盘上
                    * session的活化：
                        在服务器启动后，将session文件转化为内存中的对象即可
            3. session的失效时间
                1 服务器关闭
                2 session对象调用invalidate（）
                3 session默认失效时间 30分钟
                    选择性配置修改
                    <session-config>
                        <session-timeout>30<.session-timeout>
                    </session-config>

        5. session 的特点
            1.session用于存储一次会话的多次请求的数据，存在服务器端
            2.session可以存储任意类型，任意大小的数据

            *session 与cookie的区别
                1.session存储的数据在服务器端，cookie在客户端
                2.session没有数据大小的限制，cookie有
                3.session数据安全，cookie相对不安全

###EL表达式
    1.概念：
    2.作用
    3.语法：${表达式}
    4.注意：
        * JSP默认支持el表达式
            1.isELIgnored="true"
            2.\${表达式}


    5.使用：
        1.运算：
            1.算术，运算，逻辑，空运算
                ${empty list}

        2.获取值
            1.
            2.语法：
                1.${requestScope.name}

                    域名称：
                        pageScope
                        requestScope
                        sessionScope
                        applicationScope
                2.${键名}


###格式化日期
   SimpleD

###Filter 过滤器
    1.概念
    2.快速入门
        1.步骤
            filter包里demo1

    3.细节
        1.web.xml配置
            <filter>  //给类起名字
                <filter-name>demo1</filter-name>
                <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
            </filter>
            <filter-mapping>   //名字拦截的路径
                <filter-name>demo1</filter-name>
                <url-pattern>/*</url-pattern>
            </filter-mapping>

        2.过滤器执行流程
            执行过滤器-->执行放行后的资源-->回来执行过滤器方向下边的代码
        3.过滤器生命周期
            1. init：在服务器启动后，会创建Filter对象，然后调用init方法，只执行一次，用于加载资源
            2. doFilter：每一次请求被拦截时都会调用，执行多次
            3. destroy：在服务器关闭后，Filter对象被销毁，如果服务器正常关闭，只执行一次，用于释放资源
        4.过滤器配置详解

        5.过滤器链（配置多个过滤器）



###JQuery
    1.快速入门
        1.下载版本--->2.导入min.js文件--->3.使用





###maven二刷笔记
        1.常用命令  mvn clean     清除项目编译信息 （清除target目录）
                    mvn compile
                    mvn text     编译
                    mvn package
                    mvn install
                    mvn deploy

        2.maven 模型
            * 项目对象模型（POM）: 1. 项目自身信息
                                  2. 项目运行所依赖的jar包
                                  3.项目运行所依赖的环境 jdk，tomcat等

            * 依赖管理模型   1.
                            2.b2b
                            3.local

            * 默认生命周期  每一个命令都对应底层的一个插件

        3.


                *冲包  scope  	
			
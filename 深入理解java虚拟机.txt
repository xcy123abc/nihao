
第二章：

	章节：运行时数据区域
		1.方法区：
		2.虚拟机栈：
		3.本地方法栈：
		4.堆：
		5.程序计时器：
		
			5.程序计时器：
					一块较小的空间，可以看作当前线程所执行的字节码行号的指示器。线程私有内存
					此内存是唯一没有规定OutOfMemoryError请情况的区域
			2.java虚拟机栈：
					线程私有 与线程生命周期相同
					虚拟机栈描述的是java方法执行的内存模型
					一个方法在栈帧中分配多大的局部变量空间是确定的
					在运行期间不会改变局部变量表的大小
					这各区域规定了两个异常StackOverflowErroe 和 OutOfMemoryError
			3.本地方法栈：
					与虚拟机栈所发挥的功能非常相似，他们的区别只是：
					虚拟机栈：为虚拟机执行java方法服务
					本地方法栈：为虚拟机使用到的Native方法服务
					在虚拟机规范中对本地方法栈中使用的语言，使用方式和数据结构没有强制规定
					因此具体的虚拟机可以自由的实现它
					甚至有的虚拟机把本地方法栈与虚拟机栈合二为一（Sun HotStop）
					与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowErroe 和
					OutOfMemoryError异常
			4.java堆（Java Heap）：
					大多应用中，java堆是java虚拟机所管理的内存中最大的一块
					java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建
					唯一的目的就是存放对象实例  几乎所有的对象实例都存放在分配
					但随着JIT编译器的发展与逃逸分析技术逐渐成熟，所有对象在堆分配也不是那么绝对了
					java堆是垃圾回收器管理的主要区域，所以很多时候被称为“GC堆”
					现代的回收器基本都采用分代回收算法，所以java堆还可细分为：
						新生代和老年代
					再细致：Eden空间  From Surivor空间 To Surivivor空间

					从内存分配的角度看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（TLAB）
					划分的目的是为了更好的回收或者分配对象实例
					会抛出OutOfMemoryError异常
			1.方法区：
				线程共享的内存区域
				存储已经被虚拟机加载的类的信息，常量 静态变量 即时编译器编译后的代码等数据
				虽然java虚拟机规范把方法区描述为堆的一个逻辑部分 但是它却有一个别名叫非堆
				java虚拟机对方法区的规范非常宽松 可以选择不实现垃圾回收
				垃圾回收在这区域的出现比较少 这区域的回收目标主要是针对常量池的回收和类型的卸载
				这个区域回收的难度较大 特别是类型的卸载 条件相当苛刻 但这部分的回收是确实有必要
				会抛出OutOfMemoryError异常
				
			运行时常量池：
					是方法区的一部分  用于存放编译期生成的各种字面值和符号引用 还会把 翻译出来的
					直接引用也存储在运行时常量池中
					会抛出OutOfMemoryError异常
					
			直接内存：不是java虚拟机规范的内存区域 但是被频繁的使用 也会抛出OutOfMemoryError异常	
					  JDK1.4中加入了NIO类 引入了基于通道（Channel）与缓冲区(Buffer)的IO方式，它可以使用Native
					  函数库直接分配java堆外内存 然后通过一个在堆存储的(DirctByteBuffer)对象
					  作为这块内存的引用进行操作 这样能够在一些场景中显著提高性能
					  * 注意：本机直接内存的分配不受到java堆大小的限制，但是受到本机总内存的限制
					          服务器管理员在配置虚拟机参数时，不能忽略直接内存。否则动态扩容时可能
							  会出现会OutOfMemoryError异常
					
	章节：HotStop虚拟机对象探秘：
		1.对象的创建	2.对象的内存分配	3.对象的访问定位

		1.对象的创建：
			类加载过后，虚拟机为对象分配空间 所需大小可以确定
			
			内存分配算法：
				指针碰撞：
					定义：
					使用：在Serial，ParNew等带有Compact过程的回收器
				空闲列表：
					定义：
					使用：使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表

			分配空间的线程安全问题：
				划分内存空间时，指针还没来得及移动，新的线程又划分同一块内存，引发线程安全问题
			解决方式：
				1.分配空间的动作进行同步处理――――实现上虚拟机采用CAS配上失败重试的方式
					保证更新操作的原子性
				2.分配内存的动作放在按照线程划分在不同的空间之中进行，（TLAB）,这样只有TLAB
					用完分配新的TLAB时才需要同步锁定，虚拟机是否使用TLAB，可以通过参数设定
					
			内存分配后，虚拟机将分配到的内存初始化为零值（不包括对象头）
			如果使用TLAB，初始化过程可以提前到TLAB分配时进行，这样保证了对象的实例字段
			在java代码中可以不赋值就直接使用 程序能够访问到这些字段的数据类型所对应的零值
			
			接下来：虚拟机对对象进行必要的设置  比如对象的数据类型 如何找到元数据信息
					对象的hash值 GC分代年龄等 这些都存放在对象头之中
					
			从虚拟机视角来看，此时对象已经产生了  但从程序员的角度来看 还需要执行init方法
			
		2.对象的内存分配：对象在内存中存储的布局可以分为三个区域
			1.对象头（Herder）	2.实例数据(Instance Data)	3.对其填充(Padding)
			
			* 对象头：包括两部分信息 
				1.存储自身运行时数据：
					hash值 GC分代年龄 偏向时间戳等
					官方称为“Mark Word” 与对象自身定义的数据无关，所以考虑空间效率
					把它设计成一个非固定的数据结构，以便在极小的空间存储更多的信息
				2.类型指针：
					虚拟机用它来确定对象是哪个类的实例
					并不是所有虚拟机实现都必须在对象数据上保留类型指针，或者说 查找对象的
					元数据信息并不一定要经过对象本身
					
					注意：如果是java数组 那对象头还必须有一块内存来记录数组长度的数据
							因为虚拟机可以通过普通的java对象的元数据信息确定java对象的大小
							但从数组的元数据中无法确定数据的大小
			
			* 实例数据：
				父类继承子类重写，都记录
				存储信息受到虚拟机分配策略参数和字段在java代码源中定义顺序的影响
				默认分配策略：宽度相同的字段被分配到一起
			
			* 填充对齐
				没有特别的含义 只起着占位符的作用
				HotStop VM 的自动内存管理系统要求对象的地址必须是八字节的整数倍
				就是说 对象的大小必须是八字节的整数倍 对象头部分刚好是八字节的倍数
				因此，当对象实例数据部分没有对其时，就需要通过对齐填充来补全
			
		3.对象的访问定位：
				java程序通过栈上的reference数据来操作堆上的具体对象
				对象的访问方式取决域虚拟机而定
				目前主流的方式有使用句柄和直接指针两种：
				
				句柄：java堆中划分一块内存作为句柄池，存放句柄
					  reference中存储的就是句柄的地址
					  而句柄中包含对象实例数据与数据类型的各自地址
					  最大的好处：
						refere中存放的是稳定的句柄地址，对象在被移动时（垃圾收集时移动对象是普遍
						的行为）时 只会改变句柄中的实例数据指针 reference本身不用改
				
				直接指针：reference中存储的直接就是对象地址
						  java堆对象的布局就必须考虑如何放置访问类型数据的相关信息
						  最大的好处：	
							 速度更快，节剩一次指针定位的开销 因为对象的访问在java中非常频繁
							 所以这类开销积少成多也非常可观
							 
				注意: HotStop用的方式是直接访问  但从整个软件开发的范围看 各种语言和框架使用句柄
						的情况也十分常见
				
	章节：OutOfMemoryErrow异常
		在java虚拟机描述的范围之中 除了程序计时器外 虚拟机内存的其他几个运行时区域都有发生
		OutOfMemoryErrow异常的可能（OOM）
		本节目的：遇到内存溢出异常时 能快速处理
		
		1.java堆溢出2.	虚拟机栈和本地方法栈溢出	
		3.方法区和运行时常量池溢出	4.本机直接内存溢出
		
			* java堆溢出：
				不断创建对象，保证对象与GC Roots之间有路径，对象数量超过限制后，就会产生内存溢出
				
				解决：一般手段是通过内存映像工具对Dump出来的堆转储快照分析，确认是内存泄漏
					  还是内存溢出。
					  
					  内存泄漏：进一步查看对象到GC Roots的引用链 找到垃圾回收器无法自动回收他们
								的原因 掌握对象的数据类型信息及GC Roots引用链信息 就可以比较准确
								的确定出泄漏代码的位置
				
					  内存溢出：如果不存在泄漏 就检查物理内存（调大） 虚拟机参数  代码检查（
					  某些对象生命周期过长 持有时间过长）  减少程序运行期的内存消耗 以上是简单思路
						
			* 虚拟机栈和本地方法栈溢出：
				规定了两个异常
				作者实验模拟产生OutOfMemory异常，结果都是产生StackOverflowErrow
					实验一：通过参数减小栈内存容量。结果:产生StackOverflowErrow异常
					
					实验二：定义大量的本地变量，增大此方法帧中的本地变量表的长度。
							结果：产生StackOverflowErrow异常
				实验结果表明：
					单线程下：栈帧太大或者虚拟栈容量太小，虚拟机都抛出StackOverflowErrow异常
							  
					多线程：通过不断建立线程的方式可以产生内存溢出异常  但是这样产生的异常和栈空间
						    的大小没有任何联系 在这种情况下 为每个栈分配的内存越大，反而越容易
							产生内存异常异常。
							如果线程数不能减少，不能更换64位虚拟机，要避免这个异常
							可以用过减小最大堆容量和栈容量来换取更多的线程。
		
			* 方法区和运行时常量池溢出
				JDK1.7开始逐步“去永久代”
				增强的类越多 就需要越大的方法区来保证动态生成的Class可以加载入内存
				一个类要被垃圾回收器回收掉，条件是比较苛刻的
				在大量生成Class的应用中，需要特别注意类的回收情况
				
			* 本机直接内存溢出：
				容量可通过参数指定  默认与java堆最大值一样
				
				中间有一段天书
				
				
				有DirectMemory导致的内存溢出，一个显著的特征是在Heap Dump文件中看不到明显的异常
				OOM之后的Dump文件很小 而程序直接或者间接使用了NIO，那就可以考虑检查一下是本机直
				接内存溢出的问题
				
				
	第二章关键字：
		Gorrvy
		系统假死
		GC Roots的引用链
		Dump
		GC Roots	
		直接指针
		句柄
		元数据
		Serial
		ParNew
		Compact
		CMS
		Mark-Sweep
		类加载
		String的intern（）
		JRockit
		J9
		永久代：JDK1.7已经把放在永久代的字符串常量池移出
		分代回收算法
		逃逸分析技术
		JIT编译器
		Native：
		栈帧：
		局部变量表：存放编译器可知的各种基本数据类型 对象引用 和teturnAddress类型
					（指向了一条字节码指令的地址）（其中long和double类型的数据占用两个
						局部变量的空间（Slot）其余数据类型占用一个）一个方法在栈帧中分配多大的局部
						变量空间是确定的，在运行期间不会改变局部变量表的大小
		reference
		句柄
		符号引用
		slot
		
第三章：垃圾回收器与内存分配策略
	3.2对象已死吗  
		引用计数算法：    可达性分析算法：  再谈引用：  对象的存活   回收方法区
	3.3垃圾回收算法
	3.4hotspot的算法实现
	3.5垃圾收集器
	3.6内存分配与回收策略
	
	3.2对象已死吗
			*引用计数算法：给对象添加一个引用计数器。值为零时就不可能再被使用。
				好处：算法实现简单，效率高，大部分情况下是个不错的算法
				缺点：很难解决对象之间相互循环・引用的问题（主流虚拟机没有选用的主要原因）
				
			*可达性分析算法：一系列称为“GC Roots”的对象作为起点。搜索过的路径称为
						引用链（Reference Chain），对象到GC Roots没有引用链相链接
						则对象是不可用的
			* GC Roots：可以作为GC Roots的对象：
				1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
				2. 方法区中类静态属性引用的对象
				3. 方法区中常量引用的对象
				4. 本地方法栈中Native方法引用的对象
			* 引用（Reference）：
				Strong Reference：强引用在，对象不会回收
				SoftReference：软引用，有用非必须的对象，内存不够则回收
				WeakReference：弱引用，非必需，生存到下一次垃圾回收之前
				PhantomReference：不影响对象的生命周期，唯一目的是对象被收集器回收时收到一个通知
			
			* 对象存活：可达性分析后如果没有gcr的引用链相连接，会被标记，判断是否执行finalize（）
						方法，该方法是对象自救的唯一一次机会
						第二次标记时如果没有建立关联，基本上就要被回收了
			* 回收方法区：
				垃圾回收主要分两部分：废弃常量 和 无用的类
				废弃常量：
					与回收java堆中的对象相似  没有类型相同的对象引用常量池中的常量，也没有其他地方
					引用（字面值），如果此时内存回收 有需要的话 这个常量就会被回收
					常量池中的其他类 接口 字段的符号引用 也类似
				无用类：条件比较苛刻：
					1.所有实例被回收  也就是java堆中不存在实例
					2.加载该类的类加载器已经被回收
					3.该类对应的java.lang.Class对象没有任何地方被引用  无法在任何地方通过反射访问
					该类
					注意：* 此时虚拟机可以对其回收，不是必然会回收
						  * 在大量使用反射 动态代理 CGLib 等ByteCode框架，动态生成JSP以及OSGi这类
						   频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证
						   永久代不会溢出
						   
						   
	3.3垃圾回收算法	：
		没有过多的算法实现，介绍算法的思想
		1.标记-清除算法	2.复制算法	3.标记-整理算法		4.分代收集算法
		
			* 标记-清除算法：
				最基本的收集算法 
				算法分两个阶段：（标记和清除）
				不足： * 两个阶段的算法效率都不高
					   * 内存琐碎（有大对象时可能要提前触发垃圾收集动作）
			* 复制算法：
				内存分两块，一次用一块，收集后把存活对象复制到另一边，上次用的内存全部清空
				优点：实现简单，运行高效
				不足：* 代价是内存缩小为原来的一半  未免太高
					  * 对象存活率高时要进行较多的复制  效率将会变低
				
				现在商业的虚拟机都采用这种算法来回收新生代，研究表明新时代对象98%是朝生夕死
				所以不需要1比1比例划分内存
				而是划分为Eden空间和两块较小的Surrvivor空间（8：1）
				当Surrvivor空间不够时，依赖老年代进行分配担保（通过这个机制，对象进入老年代）
			* 标记-整理算法：
				根据老年代的特点 提出的这种算法
				让存活的对象都向一端移动 然后直接清理掉端边界意外的内存
			* 分代收集算法：
				当前商业虚拟机的垃圾收集都采用分代收集算法。
				一般是把java堆分为新生代和老年代/根据各个年代的特点采用合适的算法
				新生代：复制算法
				老年代：标记-整理或者标记-清除算法
					
	3.4hotspot的算法实现
		1.	枚举根结点	2.安全点	3.安全区域
		
			* 枚举根结点
				GC进行时必须停止所有的java线程（重要原因是可达性分析时要保证分析过程中对象引用
				关系不能改变）（CMS也是必须要停顿）
				目前主流的java虚拟机使用的都是准确式GC：
					HotStop使用一组OopMap的数据结构来知道那些地方存放着对象引用。
					类加载完成时：HotSpot就把对象内什么偏移量上的是什么类型的数据计算出来
					JIT编译过程也会在特定的位置记录下栈和寄存器中那些位置是引用。
					这样，GC在扫描时就可以直接知道这些信息		
			* 安全点
				在特定的位置记录一些信息，这些位置称为安全点。
				程序执行时只有到了安全点才能暂定开始GC
				
				安全点的指令选定基本上是以程序“是否具有让程序长时间执行的特征”为标准选定
				最明显的特征就是指令复用  如：方法调用  循环跳转 异常跳转
				所以具有这些功能的指令才会产生安全点
				
				还有一个问题就是如何在GC发生时让所有线程停下来（不包括执行JNI调用的线程）
				
			* 安全区域：
				线程执行在这个区域的代码时  首先表示自己进入了safe region 在jvm发起gc时 
				就不用管这些标记的线程了。在线程要离开安全区域时 会检查gc是否以及完成了根
				节点枚举  （或者整个gc过程） 完成gc就继续 没有完成就等待直到gc完成
				
	3.5垃圾收集器
		1.serial收集器：最基本 最悠久 曾经
		2.parnew收集器
		3.parallel scavenge收集器
		4.serial old收集器
		5.parallel old收集器 
		6.cms收集器
		7.	g1收集器
		8.理解gc日志
		9.垃圾收集器参数总结
		
		
		
	3.6内存分配与回收策略	
		1.对象优先级在eden分配	2.大对象直接进入老年代	3.长期存活的对象将进入老年代
		4.动态对象年龄判断	5.空间分配担保



	
	第四章关键字：
		寄存器
		JIT编译
		finalize（）：完全可以忘记这个方法
		GC Roots
		ClassLoader
		可达性分析算法：
		引用计数算法：
		
		
	
	

第七章

第十二章

第十三章

第四章了解
